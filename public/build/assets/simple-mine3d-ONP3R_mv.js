import{R as ie,l as u,m as Ee,Q as V,n as W,L as J,f as B,g as j,B as ae,e as _e,M as f,o as pe,p as N,q as oe,r as le,s as Pe,j as ke,E as Xe,t as Ne,W as Ce,a as tt,b as Ye,u as qe,d as Be,v as xe,V as re,A as Qe,D as Ze,w as Te,x as ze,y as it,z as Q,I as nt,C as Z,U as st,J as ot,K as at,S as rt,P as lt,O as ct,N as Me,X as Le,H as ht,Y as ve,G as dt,k as Ie,i as we,Z as je,_ as Ae,$ as Ge,a0 as X,a1 as Ke,a2 as Je,a3 as ne,a4 as se}from"./OrbitControls--CPrXAYj.js";const ee=new ie,H=new u,K=new u,_=new V,Fe={X:new u(1,0,0),Y:new u(0,1,0),Z:new u(0,0,1)},Se={type:"change"},Ve={type:"mouseDown"},$e={type:"mouseUp",mode:null},He={type:"objectChange"};class ut extends Ee{constructor(e,t){super(),t===void 0&&(console.warn('THREE.TransformControls: The second parameter "domElement" is now mandatory.'),t=document),this.isTransformControls=!0,this.visible=!1,this.domElement=t,this.domElement.style.touchAction="none";const i=new wt;this._gizmo=i,this.add(i);const n=new bt;this._plane=n,this.add(n);const o=this;function s(w,g){let b=g;Object.defineProperty(o,w,{get:function(){return b!==void 0?b:g},set:function(x){b!==x&&(b=x,n[w]=x,i[w]=x,o.dispatchEvent({type:w+"-changed",value:x}),o.dispatchEvent(Se))}}),o[w]=g,n[w]=g,i[w]=g}s("camera",e),s("object",void 0),s("enabled",!0),s("axis",null),s("mode","translate"),s("translationSnap",null),s("rotationSnap",null),s("scaleSnap",null),s("space","world"),s("size",1),s("dragging",!1),s("showX",!0),s("showY",!0),s("showZ",!0);const a=new u,r=new u,h=new V,l=new V,d=new u,c=new V,p=new u,m=new u,y=new u,D=0,S=new u;s("worldPosition",a),s("worldPositionStart",r),s("worldQuaternion",h),s("worldQuaternionStart",l),s("cameraPosition",d),s("cameraQuaternion",c),s("pointStart",p),s("pointEnd",m),s("rotationAxis",y),s("rotationAngle",D),s("eye",S),this._offset=new u,this._startNorm=new u,this._endNorm=new u,this._cameraScale=new u,this._parentPosition=new u,this._parentQuaternion=new V,this._parentQuaternionInv=new V,this._parentScale=new u,this._worldScaleStart=new u,this._worldQuaternionInv=new V,this._worldScale=new u,this._positionStart=new u,this._quaternionStart=new V,this._scaleStart=new u,this._getPointer=mt.bind(this),this._onPointerDown=gt.bind(this),this._onPointerHover=pt.bind(this),this._onPointerMove=ft.bind(this),this._onPointerUp=yt.bind(this),this.domElement.addEventListener("pointerdown",this._onPointerDown),this.domElement.addEventListener("pointermove",this._onPointerHover),this.domElement.addEventListener("pointerup",this._onPointerUp)}updateMatrixWorld(){this.object!==void 0&&(this.object.updateMatrixWorld(),this.object.parent===null?console.error("TransformControls: The attached 3D object must be a part of the scene graph."):this.object.parent.matrixWorld.decompose(this._parentPosition,this._parentQuaternion,this._parentScale),this.object.matrixWorld.decompose(this.worldPosition,this.worldQuaternion,this._worldScale),this._parentQuaternionInv.copy(this._parentQuaternion).invert(),this._worldQuaternionInv.copy(this.worldQuaternion).invert()),this.camera.updateMatrixWorld(),this.camera.matrixWorld.decompose(this.cameraPosition,this.cameraQuaternion,this._cameraScale),this.camera.isOrthographicCamera?this.camera.getWorldDirection(this.eye).negate():this.eye.copy(this.cameraPosition).sub(this.worldPosition).normalize(),super.updateMatrixWorld(this)}pointerHover(e){if(this.object===void 0||this.dragging===!0)return;ee.setFromCamera(e,this.camera);const t=De(this._gizmo.picker[this.mode],ee);t?this.axis=t.object.name:this.axis=null}pointerDown(e){if(!(this.object===void 0||this.dragging===!0||e.button!==0)&&this.axis!==null){ee.setFromCamera(e,this.camera);const t=De(this._plane,ee,!0);t&&(this.object.updateMatrixWorld(),this.object.parent.updateMatrixWorld(),this._positionStart.copy(this.object.position),this._quaternionStart.copy(this.object.quaternion),this._scaleStart.copy(this.object.scale),this.object.matrixWorld.decompose(this.worldPositionStart,this.worldQuaternionStart,this._worldScaleStart),this.pointStart.copy(t.point).sub(this.worldPositionStart)),this.dragging=!0,Ve.mode=this.mode,this.dispatchEvent(Ve)}}pointerMove(e){const t=this.axis,i=this.mode,n=this.object;let o=this.space;if(i==="scale"?o="local":(t==="E"||t==="XYZE"||t==="XYZ")&&(o="world"),n===void 0||t===null||this.dragging===!1||e.button!==-1)return;ee.setFromCamera(e,this.camera);const s=De(this._plane,ee,!0);if(s){if(this.pointEnd.copy(s.point).sub(this.worldPositionStart),i==="translate")this._offset.copy(this.pointEnd).sub(this.pointStart),o==="local"&&t!=="XYZ"&&this._offset.applyQuaternion(this._worldQuaternionInv),t.indexOf("X")===-1&&(this._offset.x=0),t.indexOf("Y")===-1&&(this._offset.y=0),t.indexOf("Z")===-1&&(this._offset.z=0),o==="local"&&t!=="XYZ"?this._offset.applyQuaternion(this._quaternionStart).divide(this._parentScale):this._offset.applyQuaternion(this._parentQuaternionInv).divide(this._parentScale),n.position.copy(this._offset).add(this._positionStart),this.translationSnap&&(o==="local"&&(n.position.applyQuaternion(_.copy(this._quaternionStart).invert()),t.search("X")!==-1&&(n.position.x=Math.round(n.position.x/this.translationSnap)*this.translationSnap),t.search("Y")!==-1&&(n.position.y=Math.round(n.position.y/this.translationSnap)*this.translationSnap),t.search("Z")!==-1&&(n.position.z=Math.round(n.position.z/this.translationSnap)*this.translationSnap),n.position.applyQuaternion(this._quaternionStart)),o==="world"&&(n.parent&&n.position.add(H.setFromMatrixPosition(n.parent.matrixWorld)),t.search("X")!==-1&&(n.position.x=Math.round(n.position.x/this.translationSnap)*this.translationSnap),t.search("Y")!==-1&&(n.position.y=Math.round(n.position.y/this.translationSnap)*this.translationSnap),t.search("Z")!==-1&&(n.position.z=Math.round(n.position.z/this.translationSnap)*this.translationSnap),n.parent&&n.position.sub(H.setFromMatrixPosition(n.parent.matrixWorld))));else if(i==="scale"){if(t.search("XYZ")!==-1){let a=this.pointEnd.length()/this.pointStart.length();this.pointEnd.dot(this.pointStart)<0&&(a*=-1),K.set(a,a,a)}else H.copy(this.pointStart),K.copy(this.pointEnd),H.applyQuaternion(this._worldQuaternionInv),K.applyQuaternion(this._worldQuaternionInv),K.divide(H),t.search("X")===-1&&(K.x=1),t.search("Y")===-1&&(K.y=1),t.search("Z")===-1&&(K.z=1);n.scale.copy(this._scaleStart).multiply(K),this.scaleSnap&&(t.search("X")!==-1&&(n.scale.x=Math.round(n.scale.x/this.scaleSnap)*this.scaleSnap||this.scaleSnap),t.search("Y")!==-1&&(n.scale.y=Math.round(n.scale.y/this.scaleSnap)*this.scaleSnap||this.scaleSnap),t.search("Z")!==-1&&(n.scale.z=Math.round(n.scale.z/this.scaleSnap)*this.scaleSnap||this.scaleSnap))}else if(i==="rotate"){this._offset.copy(this.pointEnd).sub(this.pointStart);const a=20/this.worldPosition.distanceTo(H.setFromMatrixPosition(this.camera.matrixWorld));let r=!1;t==="XYZE"?(this.rotationAxis.copy(this._offset).cross(this.eye).normalize(),this.rotationAngle=this._offset.dot(H.copy(this.rotationAxis).cross(this.eye))*a):(t==="X"||t==="Y"||t==="Z")&&(this.rotationAxis.copy(Fe[t]),H.copy(Fe[t]),o==="local"&&H.applyQuaternion(this.worldQuaternion),H.cross(this.eye),H.length()===0?r=!0:this.rotationAngle=this._offset.dot(H.normalize())*a),(t==="E"||r)&&(this.rotationAxis.copy(this.eye),this.rotationAngle=this.pointEnd.angleTo(this.pointStart),this._startNorm.copy(this.pointStart).normalize(),this._endNorm.copy(this.pointEnd).normalize(),this.rotationAngle*=this._endNorm.cross(this._startNorm).dot(this.eye)<0?1:-1),this.rotationSnap&&(this.rotationAngle=Math.round(this.rotationAngle/this.rotationSnap)*this.rotationSnap),o==="local"&&t!=="E"&&t!=="XYZE"?(n.quaternion.copy(this._quaternionStart),n.quaternion.multiply(_.setFromAxisAngle(this.rotationAxis,this.rotationAngle)).normalize()):(this.rotationAxis.applyQuaternion(this._parentQuaternionInv),n.quaternion.copy(_.setFromAxisAngle(this.rotationAxis,this.rotationAngle)),n.quaternion.multiply(this._quaternionStart).normalize())}this.dispatchEvent(Se),this.dispatchEvent(He)}}pointerUp(e){e.button===0&&(this.dragging&&this.axis!==null&&($e.mode=this.mode,this.dispatchEvent($e)),this.dragging=!1,this.axis=null)}dispose(){this.domElement.removeEventListener("pointerdown",this._onPointerDown),this.domElement.removeEventListener("pointermove",this._onPointerHover),this.domElement.removeEventListener("pointermove",this._onPointerMove),this.domElement.removeEventListener("pointerup",this._onPointerUp),this.traverse(function(e){e.geometry&&e.geometry.dispose(),e.material&&e.material.dispose()})}attach(e){return this.object=e,this.visible=!0,this}detach(){return this.object=void 0,this.visible=!1,this.axis=null,this}reset(){this.enabled&&this.dragging&&(this.object.position.copy(this._positionStart),this.object.quaternion.copy(this._quaternionStart),this.object.scale.copy(this._scaleStart),this.dispatchEvent(Se),this.dispatchEvent(He),this.pointStart.copy(this.pointEnd))}getRaycaster(){return ee}getMode(){return this.mode}setMode(e){this.mode=e}setTranslationSnap(e){this.translationSnap=e}setRotationSnap(e){this.rotationSnap=e}setScaleSnap(e){this.scaleSnap=e}setSize(e){this.size=e}setSpace(e){this.space=e}}function mt(M){if(this.domElement.ownerDocument.pointerLockElement)return{x:0,y:0,button:M.button};{const e=this.domElement.getBoundingClientRect();return{x:(M.clientX-e.left)/e.width*2-1,y:-(M.clientY-e.top)/e.height*2+1,button:M.button}}}function pt(M){if(this.enabled)switch(M.pointerType){case"mouse":case"pen":this.pointerHover(this._getPointer(M));break}}function gt(M){this.enabled&&(document.pointerLockElement||this.domElement.setPointerCapture(M.pointerId),this.domElement.addEventListener("pointermove",this._onPointerMove),this.pointerHover(this._getPointer(M)),this.pointerDown(this._getPointer(M)))}function ft(M){this.enabled&&this.pointerMove(this._getPointer(M))}function yt(M){this.enabled&&(this.domElement.releasePointerCapture(M.pointerId),this.domElement.removeEventListener("pointermove",this._onPointerMove),this.pointerUp(this._getPointer(M)))}function De(M,e,t){const i=e.intersectObject(M,!0);for(let n=0;n<i.length;n++)if(i[n].object.visible||t)return i[n];return!1}const ge=new Xe,I=new u(0,1,0),Re=new u(0,0,0),We=new Ne,fe=new V,be=new V,Y=new u,Ue=new Ne,de=new u(1,0,0),te=new u(0,1,0),ue=new u(0,0,1),ye=new u,ce=new u,he=new u;class wt extends Ee{constructor(){super(),this.isTransformControlsGizmo=!0,this.type="TransformControlsGizmo";const e=new W({depthTest:!1,depthWrite:!1,fog:!1,toneMapped:!1,transparent:!0}),t=new J({depthTest:!1,depthWrite:!1,fog:!1,toneMapped:!1,transparent:!0}),i=e.clone();i.opacity=.15;const n=t.clone();n.opacity=.5;const o=e.clone();o.color.setHex(16711680);const s=e.clone();s.color.setHex(65280);const a=e.clone();a.color.setHex(255);const r=e.clone();r.color.setHex(16711680),r.opacity=.5;const h=e.clone();h.color.setHex(65280),h.opacity=.5;const l=e.clone();l.color.setHex(255),l.opacity=.5;const d=e.clone();d.opacity=.25;const c=e.clone();c.color.setHex(16776960),c.opacity=.25,e.clone().color.setHex(16776960);const m=e.clone();m.color.setHex(7895160);const y=new B(0,.04,.1,12);y.translate(0,.05,0);const D=new j(.08,.08,.08);D.translate(0,.04,0);const S=new ae;S.setAttribute("position",new _e([0,0,0,1,0,0],3));const w=new B(.0075,.0075,.5,3);w.translate(0,.25,0);function g(T,G){const L=new le(T,.0075,3,64,G*Math.PI*2);return L.rotateY(Math.PI/2),L.rotateX(Math.PI/2),L}function b(){const T=new ae;return T.setAttribute("position",new _e([0,0,0,1,1,1],3)),T}const x={X:[[new f(y,o),[.5,0,0],[0,0,-Math.PI/2]],[new f(y,o),[-.5,0,0],[0,0,Math.PI/2]],[new f(w,o),[0,0,0],[0,0,-Math.PI/2]]],Y:[[new f(y,s),[0,.5,0]],[new f(y,s),[0,-.5,0],[Math.PI,0,0]],[new f(w,s)]],Z:[[new f(y,a),[0,0,.5],[Math.PI/2,0,0]],[new f(y,a),[0,0,-.5],[-Math.PI/2,0,0]],[new f(w,a),null,[Math.PI/2,0,0]]],XYZ:[[new f(new pe(.1,0),d.clone()),[0,0,0]]],XY:[[new f(new j(.15,.15,.01),l.clone()),[.15,.15,0]]],YZ:[[new f(new j(.15,.15,.01),r.clone()),[0,.15,.15],[0,Math.PI/2,0]]],XZ:[[new f(new j(.15,.15,.01),h.clone()),[.15,0,.15],[-Math.PI/2,0,0]]]},v={X:[[new f(new B(.2,0,.6,4),i),[.3,0,0],[0,0,-Math.PI/2]],[new f(new B(.2,0,.6,4),i),[-.3,0,0],[0,0,Math.PI/2]]],Y:[[new f(new B(.2,0,.6,4),i),[0,.3,0]],[new f(new B(.2,0,.6,4),i),[0,-.3,0],[0,0,Math.PI]]],Z:[[new f(new B(.2,0,.6,4),i),[0,0,.3],[Math.PI/2,0,0]],[new f(new B(.2,0,.6,4),i),[0,0,-.3],[-Math.PI/2,0,0]]],XYZ:[[new f(new pe(.2,0),i)]],XY:[[new f(new j(.2,.2,.01),i),[.15,.15,0]]],YZ:[[new f(new j(.2,.2,.01),i),[0,.15,.15],[0,Math.PI/2,0]]],XZ:[[new f(new j(.2,.2,.01),i),[.15,0,.15],[-Math.PI/2,0,0]]]},E={START:[[new f(new pe(.01,2),n),null,null,null,"helper"]],END:[[new f(new pe(.01,2),n),null,null,null,"helper"]],DELTA:[[new N(b(),n),null,null,null,"helper"]],X:[[new N(S,n.clone()),[-1e3,0,0],null,[1e6,1,1],"helper"]],Y:[[new N(S,n.clone()),[0,-1e3,0],[0,0,Math.PI/2],[1e6,1,1],"helper"]],Z:[[new N(S,n.clone()),[0,0,-1e3],[0,-Math.PI/2,0],[1e6,1,1],"helper"]]},z={XYZE:[[new f(g(.5,1),m),null,[0,Math.PI/2,0]]],X:[[new f(g(.5,.5),o)]],Y:[[new f(g(.5,.5),s),null,[0,0,-Math.PI/2]]],Z:[[new f(g(.5,.5),a),null,[0,Math.PI/2,0]]],E:[[new f(g(.75,1),c),null,[0,Math.PI/2,0]]]},C={AXIS:[[new N(S,n.clone()),[-1e3,0,0],null,[1e6,1,1],"helper"]]},O={XYZE:[[new f(new oe(.25,10,8),i)]],X:[[new f(new le(.5,.1,4,24),i),[0,0,0],[0,-Math.PI/2,-Math.PI/2]]],Y:[[new f(new le(.5,.1,4,24),i),[0,0,0],[Math.PI/2,0,0]]],Z:[[new f(new le(.5,.1,4,24),i),[0,0,0],[0,0,-Math.PI/2]]],E:[[new f(new le(.75,.1,2,24),i)]]},A={X:[[new f(D,o),[.5,0,0],[0,0,-Math.PI/2]],[new f(w,o),[0,0,0],[0,0,-Math.PI/2]],[new f(D,o),[-.5,0,0],[0,0,Math.PI/2]]],Y:[[new f(D,s),[0,.5,0]],[new f(w,s)],[new f(D,s),[0,-.5,0],[0,0,Math.PI]]],Z:[[new f(D,a),[0,0,.5],[Math.PI/2,0,0]],[new f(w,a),[0,0,0],[Math.PI/2,0,0]],[new f(D,a),[0,0,-.5],[-Math.PI/2,0,0]]],XY:[[new f(new j(.15,.15,.01),l),[.15,.15,0]]],YZ:[[new f(new j(.15,.15,.01),r),[0,.15,.15],[0,Math.PI/2,0]]],XZ:[[new f(new j(.15,.15,.01),h),[.15,0,.15],[-Math.PI/2,0,0]]],XYZ:[[new f(new j(.1,.1,.1),d.clone())]]},q={X:[[new f(new B(.2,0,.6,4),i),[.3,0,0],[0,0,-Math.PI/2]],[new f(new B(.2,0,.6,4),i),[-.3,0,0],[0,0,Math.PI/2]]],Y:[[new f(new B(.2,0,.6,4),i),[0,.3,0]],[new f(new B(.2,0,.6,4),i),[0,-.3,0],[0,0,Math.PI]]],Z:[[new f(new B(.2,0,.6,4),i),[0,0,.3],[Math.PI/2,0,0]],[new f(new B(.2,0,.6,4),i),[0,0,-.3],[-Math.PI/2,0,0]]],XY:[[new f(new j(.2,.2,.01),i),[.15,.15,0]]],YZ:[[new f(new j(.2,.2,.01),i),[0,.15,.15],[0,Math.PI/2,0]]],XZ:[[new f(new j(.2,.2,.01),i),[.15,0,.15],[-Math.PI/2,0,0]]],XYZ:[[new f(new j(.2,.2,.2),i),[0,0,0]]]},R={X:[[new N(S,n.clone()),[-1e3,0,0],null,[1e6,1,1],"helper"]],Y:[[new N(S,n.clone()),[0,-1e3,0],[0,0,Math.PI/2],[1e6,1,1],"helper"]],Z:[[new N(S,n.clone()),[0,0,-1e3],[0,-Math.PI/2,0],[1e6,1,1],"helper"]]};function P(T){const G=new Ee;for(const L in T)for(let F=T[L].length;F--;){const k=T[L][F][0].clone(),$=T[L][F][1],U=T[L][F][2],me=T[L][F][3],et=T[L][F][4];k.name=L,k.tag=et,$&&k.position.set($[0],$[1],$[2]),U&&k.rotation.set(U[0],U[1],U[2]),me&&k.scale.set(me[0],me[1],me[2]),k.updateMatrix();const Oe=k.geometry.clone();Oe.applyMatrix4(k.matrix),k.geometry=Oe,k.renderOrder=1/0,k.position.set(0,0,0),k.rotation.set(0,0,0),k.scale.set(1,1,1),G.add(k)}return G}this.gizmo={},this.picker={},this.helper={},this.add(this.gizmo.translate=P(x)),this.add(this.gizmo.rotate=P(z)),this.add(this.gizmo.scale=P(A)),this.add(this.picker.translate=P(v)),this.add(this.picker.rotate=P(O)),this.add(this.picker.scale=P(q)),this.add(this.helper.translate=P(E)),this.add(this.helper.rotate=P(C)),this.add(this.helper.scale=P(R)),this.picker.translate.visible=!1,this.picker.rotate.visible=!1,this.picker.scale.visible=!1}updateMatrixWorld(e){const i=(this.mode==="scale"?"local":this.space)==="local"?this.worldQuaternion:be;this.gizmo.translate.visible=this.mode==="translate",this.gizmo.rotate.visible=this.mode==="rotate",this.gizmo.scale.visible=this.mode==="scale",this.helper.translate.visible=this.mode==="translate",this.helper.rotate.visible=this.mode==="rotate",this.helper.scale.visible=this.mode==="scale";let n=[];n=n.concat(this.picker[this.mode].children),n=n.concat(this.gizmo[this.mode].children),n=n.concat(this.helper[this.mode].children);for(let o=0;o<n.length;o++){const s=n[o];s.visible=!0,s.rotation.set(0,0,0),s.position.copy(this.worldPosition);let a;if(this.camera.isOrthographicCamera?a=(this.camera.top-this.camera.bottom)/this.camera.zoom:a=this.worldPosition.distanceTo(this.cameraPosition)*Math.min(1.9*Math.tan(Math.PI*this.camera.fov/360)/this.camera.zoom,7),s.scale.set(1,1,1).multiplyScalar(a*this.size/4),s.tag==="helper"){s.visible=!1,s.name==="AXIS"?(s.visible=!!this.axis,this.axis==="X"&&(_.setFromEuler(ge.set(0,0,0)),s.quaternion.copy(i).multiply(_),Math.abs(I.copy(de).applyQuaternion(i).dot(this.eye))>.9&&(s.visible=!1)),this.axis==="Y"&&(_.setFromEuler(ge.set(0,0,Math.PI/2)),s.quaternion.copy(i).multiply(_),Math.abs(I.copy(te).applyQuaternion(i).dot(this.eye))>.9&&(s.visible=!1)),this.axis==="Z"&&(_.setFromEuler(ge.set(0,Math.PI/2,0)),s.quaternion.copy(i).multiply(_),Math.abs(I.copy(ue).applyQuaternion(i).dot(this.eye))>.9&&(s.visible=!1)),this.axis==="XYZE"&&(_.setFromEuler(ge.set(0,Math.PI/2,0)),I.copy(this.rotationAxis),s.quaternion.setFromRotationMatrix(We.lookAt(Re,I,te)),s.quaternion.multiply(_),s.visible=this.dragging),this.axis==="E"&&(s.visible=!1)):s.name==="START"?(s.position.copy(this.worldPositionStart),s.visible=this.dragging):s.name==="END"?(s.position.copy(this.worldPosition),s.visible=this.dragging):s.name==="DELTA"?(s.position.copy(this.worldPositionStart),s.quaternion.copy(this.worldQuaternionStart),H.set(1e-10,1e-10,1e-10).add(this.worldPositionStart).sub(this.worldPosition).multiplyScalar(-1),H.applyQuaternion(this.worldQuaternionStart.clone().invert()),s.scale.copy(H),s.visible=this.dragging):(s.quaternion.copy(i),this.dragging?s.position.copy(this.worldPositionStart):s.position.copy(this.worldPosition),this.axis&&(s.visible=this.axis.search(s.name)!==-1));continue}s.quaternion.copy(i),this.mode==="translate"||this.mode==="scale"?(s.name==="X"&&Math.abs(I.copy(de).applyQuaternion(i).dot(this.eye))>.99&&(s.scale.set(1e-10,1e-10,1e-10),s.visible=!1),s.name==="Y"&&Math.abs(I.copy(te).applyQuaternion(i).dot(this.eye))>.99&&(s.scale.set(1e-10,1e-10,1e-10),s.visible=!1),s.name==="Z"&&Math.abs(I.copy(ue).applyQuaternion(i).dot(this.eye))>.99&&(s.scale.set(1e-10,1e-10,1e-10),s.visible=!1),s.name==="XY"&&Math.abs(I.copy(ue).applyQuaternion(i).dot(this.eye))<.2&&(s.scale.set(1e-10,1e-10,1e-10),s.visible=!1),s.name==="YZ"&&Math.abs(I.copy(de).applyQuaternion(i).dot(this.eye))<.2&&(s.scale.set(1e-10,1e-10,1e-10),s.visible=!1),s.name==="XZ"&&Math.abs(I.copy(te).applyQuaternion(i).dot(this.eye))<.2&&(s.scale.set(1e-10,1e-10,1e-10),s.visible=!1)):this.mode==="rotate"&&(fe.copy(i),I.copy(this.eye).applyQuaternion(_.copy(i).invert()),s.name.search("E")!==-1&&s.quaternion.setFromRotationMatrix(We.lookAt(this.eye,Re,te)),s.name==="X"&&(_.setFromAxisAngle(de,Math.atan2(-I.y,I.z)),_.multiplyQuaternions(fe,_),s.quaternion.copy(_)),s.name==="Y"&&(_.setFromAxisAngle(te,Math.atan2(I.x,I.z)),_.multiplyQuaternions(fe,_),s.quaternion.copy(_)),s.name==="Z"&&(_.setFromAxisAngle(ue,Math.atan2(I.y,I.x)),_.multiplyQuaternions(fe,_),s.quaternion.copy(_))),s.visible=s.visible&&(s.name.indexOf("X")===-1||this.showX),s.visible=s.visible&&(s.name.indexOf("Y")===-1||this.showY),s.visible=s.visible&&(s.name.indexOf("Z")===-1||this.showZ),s.visible=s.visible&&(s.name.indexOf("E")===-1||this.showX&&this.showY&&this.showZ),s.material._color=s.material._color||s.material.color.clone(),s.material._opacity=s.material._opacity||s.material.opacity,s.material.color.copy(s.material._color),s.material.opacity=s.material._opacity,this.enabled&&this.axis&&(s.name===this.axis||this.axis.split("").some(function(r){return s.name===r}))&&(s.material.color.setHex(16776960),s.material.opacity=1)}super.updateMatrixWorld(e)}}class bt extends f{constructor(){super(new Pe(1e5,1e5,2,2),new W({visible:!1,wireframe:!0,side:ke,transparent:!0,opacity:.1,toneMapped:!1})),this.isTransformControlsPlane=!0,this.type="TransformControlsPlane"}updateMatrixWorld(e){let t=this.space;switch(this.position.copy(this.worldPosition),this.mode==="scale"&&(t="local"),ye.copy(de).applyQuaternion(t==="local"?this.worldQuaternion:be),ce.copy(te).applyQuaternion(t==="local"?this.worldQuaternion:be),he.copy(ue).applyQuaternion(t==="local"?this.worldQuaternion:be),I.copy(ce),this.mode){case"translate":case"scale":switch(this.axis){case"X":I.copy(this.eye).cross(ye),Y.copy(ye).cross(I);break;case"Y":I.copy(this.eye).cross(ce),Y.copy(ce).cross(I);break;case"Z":I.copy(this.eye).cross(he),Y.copy(he).cross(I);break;case"XY":Y.copy(he);break;case"YZ":Y.copy(ye);break;case"XZ":I.copy(he),Y.copy(ce);break;case"XYZ":case"E":Y.set(0,0,0);break}break;case"rotate":default:Y.set(0,0,0)}Y.length()===0?this.quaternion.copy(this.cameraQuaternion):(Ue.lookAt(H.set(0,0,0),Y,I),this.quaternion.setFromRotationMatrix(Ue)),super.updateMatrixWorld(e)}}class vt{constructor(e,t={}){this.container=e,this.options={antialias:!0,alpha:!0,powerPreference:"high-performance",stencil:!0,depth:!0,logarithmicDepthBuffer:!0,...t},this.renderer=null,this.isWebGL2Supported=!1,this.capabilities={},this.extensions=new Map,this.init()}init(){const e=document.createElement("canvas"),t=e.getContext("webgl2",this.options);t?(this.isWebGL2Supported=!0,console.log("✅ WebGL2 supported and initialized"),this.renderer=new Ce({canvas:e,context:t,...this.options}),this.setupWebGL2Features()):(console.warn("⚠️ WebGL2 not supported, falling back to WebGL1"),this.isWebGL2Supported=!1,this.renderer=new Ce(this.options)),this.setupRenderer(),this.container.appendChild(this.renderer.domElement)}setupWebGL2Features(){if(!this.isWebGL2Supported)return;const e=this.renderer.getContext();this.capabilities={maxTextureSize:e.getParameter(e.MAX_TEXTURE_SIZE),maxCubeMapTextureSize:e.getParameter(e.MAX_CUBE_MAP_TEXTURE_SIZE),maxArrayTextureLayers:e.getParameter(e.MAX_ARRAY_TEXTURE_LAYERS),max3DTextureSize:e.getParameter(e.MAX_3D_TEXTURE_SIZE),maxVertexUniformBlocks:e.getParameter(e.MAX_VERTEX_UNIFORM_BLOCKS),maxFragmentUniformBlocks:e.getParameter(e.MAX_FRAGMENT_UNIFORM_BLOCKS),maxUniformBlockSize:e.getParameter(e.MAX_UNIFORM_BLOCK_SIZE),maxVertexOutputComponents:e.getParameter(e.MAX_VERTEX_OUTPUT_COMPONENTS),maxFragmentInputComponents:e.getParameter(e.MAX_FRAGMENT_INPUT_COMPONENTS)},e.getSupportedExtensions().forEach(i=>{if(i.includes("EXT_")||i.includes("WEBGL_")||i.includes("OES_"))try{const n=e.getExtension(i);n&&this.extensions.set(i,n)}catch{console.warn(`Failed to load extension: ${i}`)}}),console.log("📊 WebGL2 Capabilities:",this.capabilities),console.log("🔧 Available Extensions:",Array.from(this.extensions.keys())),this.setupAdvancedFeatures()}setupAdvancedFeatures(){const e=this.renderer;this.isWebGL2Supported&&(e.shadowMap.enabled=!0,e.shadowMap.type=tt,e.shadowMap.autoUpdate=!0),e.outputColorSpace=Ye,e.toneMapping=qe,e.toneMappingExposure=1.2,e.sortObjects=!0,e.setClearColor(8900331,1)}setupRenderer(){this.renderer.setSize(this.container.clientWidth,this.container.clientHeight),this.renderer.setPixelRatio(Math.min(window.devicePixelRatio,2)),this.renderer.info.autoReset=!1,this.setupDebugInfo()}setupDebugInfo(){this.performanceMonitor={frameCount:0,lastTime:performance.now(),fps:0,drawCalls:0,triangles:0,points:0,lines:0},this.options.debug&&this.createDebugPanel()}createDebugPanel(){const e=document.createElement("div");e.id="webgl2-debug-panel",e.style.cssText=`
            position: fixed;
            top: 10px;
            left: 10px;
            background: rgba(0,0,0,0.8);
            color: #00ff00;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            padding: 10px;
            border-radius: 5px;
            z-index: 10000;
            min-width: 200px;
        `,e.innerHTML=`
            <div><strong>🚀 WebGL${this.isWebGL2Supported?"2":"1"} Renderer</strong></div>
            <div id="fps-counter">FPS: --</div>
            <div id="draw-calls">Draw Calls: --</div>
            <div id="triangles">Triangles: --</div>
            <div id="memory-usage">Memory: --</div>
            <div id="webgl-version">Version: ${this.isWebGL2Supported?"WebGL2":"WebGL1"}</div>
        `,document.body.appendChild(e),this.debugPanel=e}updateDebugInfo(){if(!this.debugPanel)return;const e=this.performanceMonitor,t=this.renderer.info;e.frameCount++;const i=performance.now();if(i-e.lastTime>=1e3){e.fps=Math.round(e.frameCount*1e3/(i-e.lastTime)),e.frameCount=0,e.lastTime=i,document.getElementById("fps-counter").textContent=`FPS: ${e.fps}`,document.getElementById("draw-calls").textContent=`Draw Calls: ${t.render.calls}`,document.getElementById("triangles").textContent=`Triangles: ${t.render.triangles}`;const n=(t.memory.geometries+t.memory.textures)*.001;document.getElementById("memory-usage").textContent=`Memory: ${n.toFixed(1)}MB`}}createAdvancedMaterial(e,t={}){const i={transparent:t.transparent||!1,opacity:t.opacity||1,color:t.color||16777215,...t};let n;switch(e){case"tunnel":n=new xe({...i,metalness:.1,roughness:.8,clearcoat:.1,clearcoatRoughness:.2,reflectivity:.1,sheen:.1,sheenColor:4473924});break;case"rock":n=new Be({...i,metalness:.05,roughness:.95,normalScale:new re(.5,.5)});break;case"metal":n=new xe({...i,metalness:.9,roughness:.1,clearcoat:1,clearcoatRoughness:.1,reflectivity:.9});break;case"conveyor":n=new xe({...i,metalness:.3,roughness:.4,clearcoat:.8,clearcoatRoughness:.2,sheen:.2,sheenColor:16755200});break;default:n=new Be(i)}return this.isWebGL2Supported&&(n.defines=n.defines||{},n.defines.USE_WEBGL2=""),n}createAdvancedLighting(e){const t={ambient:null,directional:null,shadows:[]};t.ambient=new Qe(4210752,.4),e.add(t.ambient),t.directional=new Ze(16777215,.8),t.directional.position.set(50,50,25),t.directional.castShadow=!0,this.isWebGL2Supported?(t.directional.shadow.mapSize.width=4096,t.directional.shadow.mapSize.height=4096,t.directional.shadow.camera.near=.1,t.directional.shadow.camera.far=200,t.directional.shadow.camera.left=-50,t.directional.shadow.camera.right=50,t.directional.shadow.camera.top=50,t.directional.shadow.camera.bottom=-50,t.directional.shadow.bias=-1e-4,t.directional.shadow.normalBias=.02):(t.directional.shadow.mapSize.width=2048,t.directional.shadow.mapSize.height=2048),e.add(t.directional);const i=new Te(16753920,.5,30);i.position.set(-10,-5,10),i.castShadow=this.isWebGL2Supported,e.add(i);const n=new Te(16753920,.5,30);return n.position.set(15,-5,-10),n.castShadow=this.isWebGL2Supported,e.add(n),t.shadows.push(i,n),t}render(e,t){this.renderer.render(e,t),this.options.debug&&this.updateDebugInfo(),this.renderer.info.reset()}resize(e,t){this.renderer.setSize(e,t),this.renderer.setPixelRatio(Math.min(window.devicePixelRatio,2))}dispose(){this.debugPanel&&document.body.removeChild(this.debugPanel),this.renderer.dispose(),this.extensions.clear()}supportsInstancedRendering(){return this.isWebGL2Supported}supportsVolumeRendering(){return this.isWebGL2Supported&&this.extensions.has("EXT_texture_3D")}getMaxTextureUnits(){return this.capabilities.maxTextureSize||16}}class xt{constructor(e,t={}){this.scene=e,this.options={enableSpatialPartitioning:!0,gridSize:10,maxObjectsPerCell:20,enableContinuousDetection:!0,debugVisualization:t.debug||!1,toleranceDistance:.1,...t},this.spatialGrid=new Map,this.dynamicObjects=new Set,this.staticObjects=new Set,this.collisionPairs=new Set,this.callbacks=new Map,this.raycaster=new ie,this.tempBox3=new ze,this.tempSphere=new it,this.tempVector=new u,this.debugMeshes=[],this.init()}init(){console.log("🔍 Collision Detection System initialized"),this.options.debugVisualization&&this.setupDebugVisualization()}registerObject(e,t="static",i={}){return e.userData||(e.userData={}),e.userData.collisionData={type:t,enabled:!0,bounds:null,lastPosition:e.position.clone(),velocity:new u,metadata:i,id:e.uuid||Q.generateUUID()},this.updateObjectBounds(e),t==="dynamic"?this.dynamicObjects.add(e):this.staticObjects.add(e),this.options.enableSpatialPartitioning&&this.addToSpatialGrid(e),console.log(`📦 Registered ${t} object for collision:`,e.userData.collisionData.id),e.userData.collisionData.id}unregisterObject(e){var i;if(!((i=e.userData)!=null&&i.collisionData))return;const t=e.userData.collisionData.id;this.dynamicObjects.delete(e),this.staticObjects.delete(e),this.removeFromSpatialGrid(e),this.callbacks.delete(t),delete e.userData.collisionData,console.log("🗑️ Unregistered collision object:",t)}updateObjectBounds(e){var i;if(!((i=e.userData)!=null&&i.collisionData))return;const t=e.userData.collisionData;if(e.geometry){e.geometry.boundingBox||e.geometry.computeBoundingBox();const n=e.geometry.boundingBox.clone();n.applyMatrix4(e.matrixWorld),t.bounds=n}else{const n=new ze().setFromObject(e);t.bounds=n}if(this.options.enableSpatialPartitioning){const n=e.position.clone();n.distanceTo(t.lastPosition)>.1&&(this.removeFromSpatialGrid(e),this.addToSpatialGrid(e),t.lastPosition.copy(n))}}getGridKey(e){const t=this.options.gridSize,i=Math.floor(e.x/t),n=Math.floor(e.y/t),o=Math.floor(e.z/t);return`${i},${n},${o}`}addToSpatialGrid(e){var r,h;if(!((h=(r=e.userData)==null?void 0:r.collisionData)!=null&&h.bounds))return;const t=e.userData.collisionData.bounds,i=t.min,n=t.max,o=this.options.gridSize,s={x:Math.floor(i.x/o),y:Math.floor(i.y/o),z:Math.floor(i.z/o)},a={x:Math.floor(n.x/o),y:Math.floor(n.y/o),z:Math.floor(n.z/o)};for(let l=s.x;l<=a.x;l++)for(let d=s.y;d<=a.y;d++)for(let c=s.z;c<=a.z;c++){const p=`${l},${d},${c}`;this.spatialGrid.has(p)||this.spatialGrid.set(p,new Set),this.spatialGrid.get(p).add(e)}}removeFromSpatialGrid(e){for(const[t,i]of this.spatialGrid)i.delete(e),i.size===0&&this.spatialGrid.delete(t)}getNearbyObjects(e,t=5){if(!this.options.enableSpatialPartitioning)return new Set([...this.staticObjects,...this.dynamicObjects]);const i=e.position,n=this.options.gridSize,o=Math.ceil(t/n),s=new Set,a={x:Math.floor(i.x/n),y:Math.floor(i.y/n),z:Math.floor(i.z/n)};for(let r=a.x-o;r<=a.x+o;r++)for(let h=a.y-o;h<=a.y+o;h++)for(let l=a.z-o;l<=a.z+o;l++){const d=`${r},${h},${l}`,c=this.spatialGrid.get(d);c&&c.forEach(p=>{p!==e&&s.add(p)})}return s}update(){this.dynamicObjects.forEach(e=>{this.updateObjectBounds(e)}),this.collisionPairs.clear(),this.dynamicObjects.forEach(e=>{var i,n;if(!((n=(i=e.userData)==null?void 0:i.collisionData)!=null&&n.enabled))return;this.getNearbyObjects(e,10).forEach(o=>{var a,r;if(!((r=(a=o.userData)==null?void 0:a.collisionData)!=null&&r.enabled)||e===o)return;const s=this.checkCollision(e,o);if(s){const h=this.getCollisionPairId(e,o);this.collisionPairs.add(h),this.handleCollision(e,o,s)}})}),this.options.debugVisualization&&this.updateDebugVisualization()}checkCollision(e,t){const i=e.userData.collisionData,n=t.userData.collisionData;if(!i||!n||!i.bounds||!n.bounds||!i.bounds.intersectsBox(n.bounds))return null;const o=this.detailedCollisionCheck(e,t);return o?{object1:e,object2:t,point:o.point,normal:o.normal,penetration:o.penetration,distance:o.distance}:null}detailedCollisionCheck(e,t){const i=e.userData.collisionData.metadata.type||"box",n=t.userData.collisionData.metadata.type||"box";return i==="tunnel"||n==="tunnel"?this.checkTunnelCollision(e,t):i==="path"||n==="path"?this.checkPathCollision(e,t):this.checkBoxCollision(e,t)}checkTunnelCollision(e,t){const i=e.userData.collisionData,n=t.userData.collisionData;if(!i.bounds||!n.bounds)return null;const o=i.bounds,s=n.bounds,a=o.clone().intersect(s);if(a.isEmpty())return null;const r=a.getSize(new u),h=Math.min(r.x,r.y,r.z),l=o.getCenter(new u),d=s.getCenter(new u),c=d.clone().sub(l).normalize();return{point:a.getCenter(new u),normal:c,penetration:h,distance:l.distanceTo(d)}}checkPathCollision(e,t){var o;const i=e.userData.pathData,n=t.userData.collisionData.bounds;if(!i||!i.points||!n)return null;for(let s=0;s<i.points.length-1;s++){const a=new u().copy(i.points[s]),r=new u().copy(i.points[s+1]);e.localToWorld(a),e.localToWorld(r),this.raycaster.set(a,r.clone().sub(a).normalize()),this.raycaster.far=a.distanceTo(r);const h=this.raycaster.intersectObject(t,!0);if(h.length>0){const l=h[0];return{point:l.point,normal:((o=l.face)==null?void 0:o.normal)||new u(0,1,0),penetration:.1,distance:l.distance}}}return null}checkBoxCollision(e,t){const i=e.userData.collisionData.bounds,n=t.userData.collisionData.bounds,o=i.clone().intersect(n);if(o.isEmpty())return null;const s=o.getSize(new u),a=Math.min(s.x,s.y,s.z),r=i.getCenter(new u),h=n.getCenter(new u),l=h.clone().sub(r).normalize();return{point:o.getCenter(new u),normal:l,penetration:a,distance:r.distanceTo(h)}}handleCollision(e,t,i){const n=e.userData.collisionData.id,o=t.userData.collisionData.id,s=this.callbacks.get(n),a=this.callbacks.get(o);s&&s(e,t,i),a&&a(t,e,i),this.defaultCollisionResponse(e,t,i)}defaultCollisionResponse(e,t,i){if(e.userData.collisionData.type==="dynamic"){const n=i.normal.clone().multiplyScalar(-i.penetration);e.position.add(n)}}getCollisionPairId(e,t){const i=e.userData.collisionData.id,n=t.userData.collisionData.id;return i<n?`${i}-${n}`:`${n}-${i}`}registerCollisionCallback(e,t){this.callbacks.set(e,t)}validateTunnelPlacement(e,t){const i={isValid:!0,conflicts:[],warnings:[],suggestions:[]};return t.forEach(n=>{const o=this.checkCollision(e,n);o&&(i.isValid=!1,i.conflicts.push({object:n,collision:o,severity:this.calculateConflictSeverity(o)}))}),i}calculateConflictSeverity(e){const t=e.penetration;return t>2?"critical":t>1?"major":t>.5?"minor":"warning"}detectPathIntersections(e,t){var s,a;const i=((s=e.userData.pathData)==null?void 0:s.points)||[],n=((a=t.userData.pathData)==null?void 0:a.points)||[],o=[];for(let r=0;r<i.length-1;r++)for(let h=0;h<n.length-1;h++){const l=this.lineSegmentIntersection(i[r],i[r+1],n[h],n[h+1]);l&&o.push({point:l,segment1:{start:i[r],end:i[r+1]},segment2:{start:n[h],end:n[h+1]}})}return o}lineSegmentIntersection(e,t,i,n){const o=t.clone().sub(e),s=n.clone().sub(i),a=i.clone().sub(e),r=new u().crossVectors(o,s);if(r.length()<.001)return null;const h=new u().crossVectors(a,s).dot(r)/r.lengthSq(),l=new u().crossVectors(a,o).dot(r)/r.lengthSq();return h>=0&&h<=1&&l>=0&&l<=1?e.clone().add(o.multiplyScalar(h)):null}setupDebugVisualization(){console.log("🎨 Collision debug visualization enabled")}updateDebugVisualization(){this.debugMeshes.forEach(e=>{this.scene.remove(e),e.geometry.dispose(),e.material.dispose()}),this.debugMeshes=[],[...this.staticObjects,...this.dynamicObjects].forEach(e=>{var t,i;if((i=(t=e.userData)==null?void 0:t.collisionData)!=null&&i.bounds){const n=e.userData.collisionData.bounds,o=new nt(n,65280);this.scene.add(o),this.debugMeshes.push(o)}}),this.collisionPairs.forEach(e=>{})}dispose(){this.spatialGrid.clear(),this.dynamicObjects.clear(),this.staticObjects.clear(),this.collisionPairs.clear(),this.callbacks.clear(),this.debugMeshes.forEach(e=>{this.scene.remove(e),e.geometry.dispose(),e.material.dispose()}),this.debugMeshes=[]}}class Mt{constructor(e){var t;this.renderer=e,this.isWebGL2=((t=e.capabilities)==null?void 0:t.isWebGL2)||!1,this.shaders=new Map,this.uniformBuffers=new Map,console.log(`🎨 Shader Manager initialized with WebGL${this.isWebGL2?"2":"1"}`),this.initializeShaders()}initializeShaders(){this.createTunnelShader(),this.createRockShader(),this.createMetalShader(),this.createConveyorShader(),this.createDepthBasedFogShader(),this.isWebGL2&&(this.createInstancedShader(),this.createVolumetricShader())}createTunnelShader(){const e=`
            ${this.isWebGL2?"#version 300 es":""}
            ${this.isWebGL2?"in":"attribute"} vec3 position;
            ${this.isWebGL2?"in":"attribute"} vec3 normal;
            ${this.isWebGL2?"in":"attribute"} vec2 uv;
            
            uniform mat4 modelViewMatrix;
            uniform mat4 projectionMatrix;
            uniform mat3 normalMatrix;
            uniform float time;
            uniform vec3 cameraPosition;
            
            ${this.isWebGL2?"out":"varying"} vec3 vNormal;
            ${this.isWebGL2?"out":"varying"} vec2 vUv;
            ${this.isWebGL2?"out":"varying"} vec3 vWorldPosition;
            ${this.isWebGL2?"out":"varying"} vec3 vViewPosition;
            ${this.isWebGL2?"out":"varying"} float vDepth;
            
            void main() {
                vUv = uv;
                vNormal = normalize(normalMatrix * normal);
                
                vec4 worldPosition = modelViewMatrix * vec4(position, 1.0);
                vWorldPosition = worldPosition.xyz;
                vViewPosition = -worldPosition.xyz;
                
                gl_Position = projectionMatrix * worldPosition;
                vDepth = gl_Position.z / gl_Position.w;
                
                // Subtle tunnel wall movement for realism
                vec3 pos = position;
                pos += normal * sin(time * 0.5 + position.x * 0.1) * 0.01;
                
                gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
            }
        `,t=`
            ${this.isWebGL2?"#version 300 es":""}
            precision highp float;
            
            uniform vec3 diffuse;
            uniform float opacity;
            uniform float roughness;
            uniform float metalness;
            uniform float time;
            uniform vec3 cameraPosition;
            uniform sampler2D normalMap;
            uniform sampler2D roughnessMap;
            
            ${this.isWebGL2?"in":"varying"} vec3 vNormal;
            ${this.isWebGL2?"in":"varying"} vec2 vUv;
            ${this.isWebGL2?"in":"varying"} vec3 vWorldPosition;
            ${this.isWebGL2?"in":"varying"} vec3 vViewPosition;
            ${this.isWebGL2?"in":"varying"} float vDepth;
            
            ${this.isWebGL2?"out vec4 fragColor;":""}
            
            // Advanced lighting calculations
            vec3 calculateTunnelLighting(vec3 normal, vec3 viewDir, vec3 lightDir) {
                float NdotL = max(dot(normal, lightDir), 0.0);
                vec3 reflectDir = reflect(-lightDir, normal);
                float specular = pow(max(dot(viewDir, reflectDir), 0.0), 32.0);
                
                // Tunnel-specific ambient occlusion
                float ao = 1.0 - smoothstep(0.0, 2.0, length(vWorldPosition.xz));
                ao = mix(0.3, 1.0, ao);
                
                return diffuse * NdotL * ao + vec3(specular * 0.3);
            }
            
            // Moisture and humidity effects
            vec3 addHumidityEffect(vec3 color, vec3 normal, vec3 viewDir) {
                float humidity = sin(time * 0.3 + vWorldPosition.x * 0.5) * 0.5 + 0.5;
                humidity *= smoothstep(0.5, 1.0, abs(dot(normal, viewDir)));
                
                vec3 moistureColor = vec3(0.1, 0.2, 0.3);
                return mix(color, moistureColor, humidity * 0.2);
            }
            
            void main() {
                vec3 normal = normalize(vNormal);
                vec3 viewDir = normalize(cameraPosition - vWorldPosition);
                vec3 lightDir = normalize(vec3(1.0, 1.0, 0.5));
                
                // Sample normal map for surface detail
                vec3 normalMap = texture${this.isWebGL2?"":"2D"}(normalMap, vUv * 4.0).rgb * 2.0 - 1.0;
                normal = normalize(normal + normalMap * 0.3);
                
                // Calculate base lighting
                vec3 color = calculateTunnelLighting(normal, viewDir, lightDir);
                
                // Add humidity effects
                color = addHumidityEffect(color, normal, viewDir);
                
                // Depth-based fog
                float fogFactor = 1.0 - exp(-abs(vDepth) * 0.1);
                vec3 fogColor = vec3(0.1, 0.1, 0.15);
                color = mix(color, fogColor, fogFactor * 0.6);
                
                // Output
                ${this.isWebGL2?"fragColor":"gl_FragColor"} = vec4(color, opacity);
            }
        `;this.shaders.set("tunnel",{vertexShader:e,fragmentShader:t,uniforms:{diffuse:{value:new Z(8421504)},opacity:{value:1},roughness:{value:.8},metalness:{value:.1},time:{value:0},cameraPosition:{value:new u},normalMap:{value:null},roughnessMap:{value:null}}})}createRockShader(){const e=`
            ${this.isWebGL2?"#version 300 es":""}
            ${this.isWebGL2?"in":"attribute"} vec3 position;
            ${this.isWebGL2?"in":"attribute"} vec3 normal;
            ${this.isWebGL2?"in":"attribute"} vec2 uv;
            
            uniform mat4 modelViewMatrix;
            uniform mat4 projectionMatrix;
            uniform mat3 normalMatrix;
            uniform float time;
            
            ${this.isWebGL2?"out":"varying"} vec3 vNormal;
            ${this.isWebGL2?"out":"varying"} vec2 vUv;
            ${this.isWebGL2?"out":"varying"} vec3 vWorldPosition;
            ${this.isWebGL2?"out":"varying"} float vElevation;
            
            // Procedural noise function
            vec3 random3(vec3 c) {
                float j = 4096.0 * sin(dot(c, vec3(17.0, 59.4, 15.0)));
                vec3 r;
                r.z = fract(512.0 * j);
                j *= .125;
                r.x = fract(512.0 * j);
                j *= .125;
                r.y = fract(512.0 * j);
                return r - 0.5;
            }
            
            float simplex3d(vec3 p) {
                const float F3 = 0.3333333;
                const float G3 = 0.1666667;
                
                vec3 s = floor(p + dot(p, vec3(F3)));
                vec3 x = p - s + dot(s, vec3(G3));
                
                vec3 e = step(vec3(0.0), x - x.yzx);
                vec3 i1 = e * (1.0 - e.zxy);
                vec3 i2 = 1.0 - e.zxy * (1.0 - e);
                
                vec3 x1 = x - i1 + G3;
                vec3 x2 = x - i2 + 2.0 * G3;
                vec3 x3 = x - 1.0 + 3.0 * G3;
                
                vec4 w, d;
                
                w.x = dot(x, x);
                w.y = dot(x1, x1);
                w.z = dot(x2, x2);
                w.w = dot(x3, x3);
                
                w = max(0.6 - w, 0.0);
                
                d.x = dot(random3(s), x);
                d.y = dot(random3(s + i1), x1);
                d.z = dot(random3(s + i2), x2);
                d.w = dot(random3(s + 1.0), x3);
                
                w *= w;
                w *= w;
                d *= w;
                
                return dot(d, vec4(52.0));
            }
            
            void main() {
                vUv = uv;
                vNormal = normalize(normalMatrix * normal);
                
                // Add procedural rock displacement
                vec3 pos = position;
                float noise = simplex3d(position * 0.5 + time * 0.1);
                pos += normal * noise * 0.1;
                
                vec4 worldPosition = modelViewMatrix * vec4(pos, 1.0);
                vWorldPosition = worldPosition.xyz;
                vElevation = position.y;
                
                gl_Position = projectionMatrix * worldPosition;
            }
        `,t=`
            ${this.isWebGL2?"#version 300 es":""}
            precision highp float;
            
            uniform vec3 baseColor;
            uniform vec3 accentColor;
            uniform float roughness;
            uniform float time;
            
            ${this.isWebGL2?"in":"varying"} vec3 vNormal;
            ${this.isWebGL2?"in":"varying"} vec2 vUv;
            ${this.isWebGL2?"in":"varying"} vec3 vWorldPosition;
            ${this.isWebGL2?"in":"varying"} float vElevation;
            
            ${this.isWebGL2?"out vec4 fragColor;":""}
            
            vec3 calculateRockColor(vec3 normal, vec2 uv) {
                // Stratified rock layers
                float layers = sin(vElevation * 0.5) * 0.5 + 0.5;
                vec3 layerColor = mix(baseColor, accentColor, layers);
                
                // Weathering effects
                float weathering = pow(abs(dot(normal, vec3(0, 1, 0))), 2.0);
                vec3 weatheredColor = layerColor * 0.7;
                
                return mix(layerColor, weatheredColor, weathering * 0.4);
            }
            
            void main() {
                vec3 normal = normalize(vNormal);
                vec3 color = calculateRockColor(normal, vUv);
                
                // Add subtle brightness variation
                float brightness = 0.8 + 0.2 * sin(vWorldPosition.x * 0.1 + time * 0.5);
                color *= brightness;
                
                ${this.isWebGL2?"fragColor":"gl_FragColor"} = vec4(color, 1.0);
            }
        `;this.shaders.set("rock",{vertexShader:e,fragmentShader:t,uniforms:{baseColor:{value:new Z(9127187)},accentColor:{value:new Z(6636321)},roughness:{value:.9},time:{value:0}}})}createMetalShader(){const e=`
            ${this.isWebGL2?"#version 300 es":""}
            ${this.isWebGL2?"in":"attribute"} vec3 position;
            ${this.isWebGL2?"in":"attribute"} vec3 normal;
            ${this.isWebGL2?"in":"attribute"} vec2 uv;
            
            uniform mat4 modelViewMatrix;
            uniform mat4 projectionMatrix;
            uniform mat3 normalMatrix;
            
            ${this.isWebGL2?"out":"varying"} vec3 vNormal;
            ${this.isWebGL2?"out":"varying"} vec2 vUv;
            ${this.isWebGL2?"out":"varying"} vec3 vReflect;
            ${this.isWebGL2?"out":"varying"} vec3 vViewPosition;
            
            void main() {
                vUv = uv;
                vNormal = normalize(normalMatrix * normal);
                
                vec4 worldPosition = modelViewMatrix * vec4(position, 1.0);
                vViewPosition = -worldPosition.xyz;
                
                // Calculate reflection vector for environment mapping
                vec3 worldNormal = normalize(mat3(modelViewMatrix) * normal);
                vReflect = reflect(normalize(worldPosition.xyz), worldNormal);
                
                gl_Position = projectionMatrix * worldPosition;
            }
        `,t=`
            ${this.isWebGL2?"#version 300 es":""}
            precision highp float;
            
            uniform vec3 metalColor;
            uniform float metalness;
            uniform float roughness;
            uniform samplerCube envMap;
            uniform float envMapIntensity;
            
            ${this.isWebGL2?"in":"varying"} vec3 vNormal;
            ${this.isWebGL2?"in":"varying"} vec2 vUv;
            ${this.isWebGL2?"in":"varying"} vec3 vReflect;
            ${this.isWebGL2?"in":"varying"} vec3 vViewPosition;
            
            ${this.isWebGL2?"out vec4 fragColor;":""}
            
            void main() {
                vec3 normal = normalize(vNormal);
                vec3 viewDir = normalize(vViewPosition);
                
                // Base metal color
                vec3 baseColor = metalColor;
                
                // Environment reflection
                vec3 reflectVec = reflect(-viewDir, normal);
                vec3 envColor = textureCube(envMap, reflectVec).rgb;
                
                // Fresnel effect
                float fresnel = pow(1.0 - abs(dot(normal, viewDir)), 2.0);
                
                // Combine base color with environment
                vec3 finalColor = mix(baseColor, envColor * envMapIntensity, metalness * fresnel);
                
                // Add subtle surface imperfections
                float imperfection = sin(vUv.x * 100.0) * sin(vUv.y * 100.0) * 0.05 + 0.95;
                finalColor *= imperfection;
                
                ${this.isWebGL2?"fragColor":"gl_FragColor"} = vec4(finalColor, 1.0);
            }
        `;this.shaders.set("metal",{vertexShader:e,fragmentShader:t,uniforms:{metalColor:{value:new Z(8947848)},metalness:{value:.9},roughness:{value:.1},envMap:{value:null},envMapIntensity:{value:1}}})}createConveyorShader(){const e=`
            ${this.isWebGL2?"#version 300 es":""}
            ${this.isWebGL2?"in":"attribute"} vec3 position;
            ${this.isWebGL2?"in":"attribute"} vec3 normal;
            ${this.isWebGL2?"in":"attribute"} vec2 uv;
            
            uniform mat4 modelViewMatrix;
            uniform mat4 projectionMatrix;
            uniform mat3 normalMatrix;
            uniform float time;
            uniform float beltSpeed;
            
            ${this.isWebGL2?"out":"varying"} vec3 vNormal;
            ${this.isWebGL2?"out":"varying"} vec2 vUv;
            ${this.isWebGL2?"out":"varying"} vec2 vMovingUv;
            
            void main() {
                vNormal = normalize(normalMatrix * normal);
                vUv = uv;
                
                // Animated UV for moving belt effect
                vMovingUv = uv + vec2(time * beltSpeed, 0.0);
                
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
        `,t=`
            ${this.isWebGL2?"#version 300 es":""}
            precision highp float;
            
            uniform vec3 beltColor;
            uniform float metalness;
            uniform float roughness;
            uniform sampler2D beltTexture;
            
            ${this.isWebGL2?"in":"varying"} vec3 vNormal;
            ${this.isWebGL2?"in":"varying"} vec2 vUv;
            ${this.isWebGL2?"in":"varying"} vec2 vMovingUv;
            
            ${this.isWebGL2?"out vec4 fragColor;":""}
            
            void main() {
                vec3 normal = normalize(vNormal);
                
                // Sample moving belt texture
                vec3 beltPattern = texture${this.isWebGL2?"":"2D"}(beltTexture, vMovingUv).rgb;
                
                // Combine with base color
                vec3 color = beltColor * beltPattern;
                
                // Add belt segmentation lines
                float segments = sin(vMovingUv.x * 20.0) * 0.1 + 0.9;
                color *= segments;
                
                // Simple lighting
                float lighting = max(dot(normal, vec3(0.0, 1.0, 0.5)), 0.3);
                color *= lighting;
                
                ${this.isWebGL2?"fragColor":"gl_FragColor"} = vec4(color, 1.0);
            }
        `;this.shaders.set("conveyor",{vertexShader:e,fragmentShader:t,uniforms:{beltColor:{value:new Z(3355443)},metalness:{value:.3},roughness:{value:.7},time:{value:0},beltSpeed:{value:.5},beltTexture:{value:null}}})}createDepthBasedFogShader(){if(!this.isWebGL2)return;this.shaders.set("depthFog",{vertexShader:`
            #version 300 es
            in vec3 position;
            
            uniform mat4 modelViewMatrix;
            uniform mat4 projectionMatrix;
            
            out float vDepth;
            
            void main() {
                vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                vDepth = -mvPosition.z;
                gl_Position = projectionMatrix * mvPosition;
            }
        `,fragmentShader:`
            #version 300 es
            precision highp float;
            
            uniform vec3 fogColor;
            uniform float fogNear;
            uniform float fogFar;
            uniform float fogDensity;
            
            in float vDepth;
            out vec4 fragColor;
            
            void main() {
                float fogFactor = 1.0 - exp(-fogDensity * vDepth);
                fogFactor = clamp(fogFactor, 0.0, 1.0);
                
                fragColor = vec4(fogColor, fogFactor);
            }
        `,uniforms:{fogColor:{value:new Z(6316128)},fogNear:{value:10},fogFar:{value:100},fogDensity:{value:.02}}})}createInstancedShader(){if(!this.isWebGL2)return;this.shaders.set("instanced",{vertexShader:`
            #version 300 es
            in vec3 position;
            in vec3 normal;
            in vec2 uv;
            in mat4 instanceMatrix;
            in vec3 instanceColor;
            
            uniform mat4 projectionMatrix;
            uniform mat4 viewMatrix;
            uniform mat3 normalMatrix;
            
            out vec3 vNormal;
            out vec2 vUv;
            out vec3 vInstanceColor;
            
            void main() {
                vUv = uv;
                vInstanceColor = instanceColor;
                vNormal = normalize(normalMatrix * normal);
                
                vec4 worldPosition = instanceMatrix * vec4(position, 1.0);
                gl_Position = projectionMatrix * viewMatrix * worldPosition;
            }
        `,fragmentShader:`
            #version 300 es
            precision highp float;
            
            in vec3 vNormal;
            in vec2 vUv;
            in vec3 vInstanceColor;
            
            out vec4 fragColor;
            
            void main() {
                vec3 normal = normalize(vNormal);
                float lighting = max(dot(normal, vec3(0.0, 1.0, 0.5)), 0.3);
                
                vec3 color = vInstanceColor * lighting;
                fragColor = vec4(color, 1.0);
            }
        `,uniforms:{}})}createVolumetricShader(){if(!this.isWebGL2)return;this.shaders.set("volumetric",{vertexShader:`
            #version 300 es
            in vec3 position;
            
            uniform mat4 modelViewMatrix;
            uniform mat4 projectionMatrix;
            
            out vec3 vPosition;
            
            void main() {
                vPosition = position;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
        `,fragmentShader:`
            #version 300 es
            precision highp float;
            
            uniform sampler3D volumeTexture;
            uniform vec3 cameraPosition;
            uniform float stepSize;
            uniform int maxSteps;
            uniform float opacity;
            
            in vec3 vPosition;
            out vec4 fragColor;
            
            void main() {
                vec3 rayDirection = normalize(vPosition - cameraPosition);
                vec3 rayStart = vPosition;
                
                vec4 color = vec4(0.0);
                
                for (int i = 0; i < maxSteps; i++) {
                    vec3 samplePos = rayStart + rayDirection * float(i) * stepSize;
                    
                    // Sample 3D texture
                    vec4 sample = texture(volumeTexture, samplePos * 0.5 + 0.5);
                    
                    // Alpha blending
                    color.rgb += sample.rgb * sample.a * (1.0 - color.a);
                    color.a += sample.a * (1.0 - color.a);
                    
                    if (color.a > 0.95) break;
                }
                
                fragColor = vec4(color.rgb, color.a * opacity);
            }
        `,uniforms:{volumeTexture:{value:null},cameraPosition:{value:new u},stepSize:{value:.1},maxSteps:{value:64},opacity:{value:1}}})}createMaterial(e,t={}){const i=this.shaders.get(e);if(!i)return console.warn(`Shader '${e}' not found`),new W;const n=st.merge([i.uniforms,t]);return new ot({vertexShader:i.vertexShader,fragmentShader:i.fragmentShader,uniforms:n,transparent:!0,side:ke})}updateShaderUniforms(e,t){this.shaders.forEach((i,n)=>{i.uniforms.time&&(i.uniforms.time.value=e),i.uniforms.cameraPosition&&i.uniforms.cameraPosition.value.copy(t.position)})}getAvailableShaders(){return Array.from(this.shaders.keys())}dispose(){this.shaders.clear(),this.uniformBuffers.clear()}}class St{constructor(e={}){this.options={enableGPUTiming:!0,enableMemoryMonitoring:!0,enableFrameAnalysis:!0,sampleSize:60,alertThresholds:{fps:30,memoryMB:500,drawCalls:1e3},...e},this.metrics={fps:0,frameTime:0,drawCalls:0,triangles:0,memoryMB:0,gpuTime:0},this.samples={frameTimes:[],drawCalls:[],memoryUsage:[]},this.callbacks=new Set,this.isMonitoring=!1,this.gpuTimer=null,this.gpuQueries=[],this.init()}init(){this.options.enableGPUTiming&&this.initGPUTiming(),console.log("📊 Performance Monitor initialized")}initGPUTiming(){console.log("⏱️ GPU timing monitoring initialized")}startMonitoring(e){this.renderer=e,this.isMonitoring=!0,this.lastTime=performance.now(),this.frameCount=0,console.log("📊 Performance monitoring started")}stopMonitoring(){this.isMonitoring=!1,console.log("📊 Performance monitoring stopped")}update(){if(!this.isMonitoring)return;const e=performance.now(),t=e-this.lastTime;this.frameCount++,this.updateFrameMetrics(t),this.renderer&&this.updateRenderMetrics(),this.options.enableMemoryMonitoring&&this.updateMemoryMetrics(),this.checkThresholds(),this.lastTime=e}updateFrameMetrics(e){if(this.samples.frameTimes.push(e),this.samples.frameTimes.length>this.options.sampleSize&&this.samples.frameTimes.shift(),this.samples.frameTimes.length>0){const t=this.samples.frameTimes.reduce((i,n)=>i+n)/this.samples.frameTimes.length;this.metrics.fps=Math.round(1e3/t),this.metrics.frameTime=t}}updateRenderMetrics(){const e=this.renderer.info;this.metrics.drawCalls=e.render.calls,this.metrics.triangles=e.render.triangles,this.samples.drawCalls.push(e.render.calls),this.samples.drawCalls.length>this.options.sampleSize&&this.samples.drawCalls.shift()}updateMemoryMetrics(){if(this.renderer){const e=this.renderer.info,t=(e.memory.geometries+e.memory.textures)*.001;this.metrics.memoryMB=t,this.samples.memoryUsage.push(t),this.samples.memoryUsage.length>this.options.sampleSize&&this.samples.memoryUsage.shift()}performance.memory&&(this.metrics.jsHeapMB=performance.memory.usedJSHeapSize/(1024*1024))}checkThresholds(){const e=[];this.metrics.fps<this.options.alertThresholds.fps&&e.push({type:"fps",message:`Low FPS detected: ${this.metrics.fps}`,severity:"warning"}),this.metrics.memoryMB>this.options.alertThresholds.memoryMB&&e.push({type:"memory",message:`High memory usage: ${this.metrics.memoryMB.toFixed(1)}MB`,severity:"warning"}),this.metrics.drawCalls>this.options.alertThresholds.drawCalls&&e.push({type:"drawCalls",message:`High draw calls: ${this.metrics.drawCalls}`,severity:"info"}),e.length>0&&this.triggerCallbacks("alert",e)}getMetrics(){return{...this.metrics}}getDetailedReport(){return{metrics:this.getMetrics(),samples:{frameTimes:[...this.samples.frameTimes],drawCalls:[...this.samples.drawCalls],memoryUsage:[...this.samples.memoryUsage]},analysis:this.analyzePerformance()}}analyzePerformance(){const e={overallScore:"good",bottlenecks:[],recommendations:[]};this.samples.frameTimes.length>10&&this.calculateVariance(this.samples.frameTimes)>5&&(e.bottlenecks.push("Frame time instability"),e.recommendations.push("Consider reducing scene complexity or enabling LOD")),this.samples.drawCalls.reduce((n,o)=>n+o,0)/this.samples.drawCalls.length>100&&(e.bottlenecks.push("High draw call count"),e.recommendations.push("Consider object instancing or batching")),this.samples.memoryUsage.length>30&&this.calculateTrend(this.samples.memoryUsage)>.1&&(e.bottlenecks.push("Memory usage increasing"),e.recommendations.push("Check for memory leaks in geometry/texture disposal"));let i=100;return this.metrics.fps<30&&(i-=30),this.metrics.memoryMB>200&&(i-=20),this.metrics.drawCalls>500&&(i-=20),i>80?e.overallScore="excellent":i>60?e.overallScore="good":i>40?e.overallScore="fair":e.overallScore="poor",e}calculateVariance(e){const t=e.reduce((n,o)=>n+o)/e.length,i=e.reduce((n,o)=>n+Math.pow(o-t,2),0)/e.length;return Math.sqrt(i)}calculateTrend(e){if(e.length<2)return 0;const t=e.slice(0,Math.floor(e.length/2)),i=e.slice(Math.floor(e.length/2)),n=t.reduce((s,a)=>s+a)/t.length;return(i.reduce((s,a)=>s+a)/i.length-n)/n}suggestOptimizations(){const e=[];return this.analyzePerformance(),this.metrics.fps<30&&(e.push({type:"performance",priority:"high",message:"Enable WebGL2 LOD system for distant objects",action:"enableLOD"}),e.push({type:"performance",priority:"medium",message:"Reduce shadow map resolution",action:"reduceShadowQuality"})),this.metrics.drawCalls>100&&e.push({type:"optimization",priority:"medium",message:"Use instanced rendering for repeated objects",action:"enableInstancing"}),this.metrics.memoryMB>200&&e.push({type:"memory",priority:"high",message:"Implement texture compression",action:"compressTextures"}),e}onAlert(e){this.callbacks.add(e)}offAlert(e){this.callbacks.delete(e)}triggerCallbacks(e,t){this.callbacks.forEach(i=>{try{i(e,t)}catch(n){console.error("Performance monitor callback error:",n)}})}enableAutoOptimization(){this.autoOptimization=!0,setInterval(()=>{this.metrics.fps<20&&this.triggerCallbacks("autoOptimize",{action:"reduceQuality",reason:"Low FPS detected"})},5e3)}runBenchmark(e=1e4){return new Promise(t=>{performance.now();const i={...this.metrics};setTimeout(()=>{const n={...this.metrics},o={duration:e,startMetrics:i,endMetrics:n,avgFPS:this.metrics.fps,minFPS:Math.min(...this.samples.frameTimes.map(s=>1e3/s)),maxFPS:Math.max(...this.samples.frameTimes.map(s=>1e3/s)),stability:100-this.calculateVariance(this.samples.frameTimes),score:this.analyzePerformance().overallScore};t(o)},e)})}dispose(){this.stopMonitoring(),this.callbacks.clear(),this.samples={frameTimes:[],drawCalls:[],memoryUsage:[]}}}class Dt{constructor(e,t,i,n=null){this.scene=e,this.camera=t,this.renderer=i,this.viewer=n,this.isCreating=!1,this.previewObject=null,this.currentType="tunnel",this.currentPosition=new u(0,-2,0),this.parameters={tunnel:{width:3,height:3,length:10,orientation:"horizontal",angle:0},road:{width:4,height:.5,length:15,orientation:"horizontal",angle:0},rail:{width:1.5,height:.3,length:20,orientation:"horizontal",angle:0},conveyor:{width:1,height:.8,length:12,orientation:"horizontal",angle:0}},this.createdObjects=new Map,this.nextId=1,this.autoMultiPlace=!1}startCreating(e){this.isCreating=!0,this.currentType=e,this.showCreationUI(),this.createPreview(),console.log(`[MineObjectCreator] Started creating: ${e}`)}stopCreating(){this.isCreating=!1,this.hideCreationUI(),this.removePreview(),console.log("[MineObjectCreator] Stopped creating")}updateParameter(e,t){this.parameters[this.currentType]&&(e==="orientation"?this.parameters[this.currentType][e]=t:this.parameters[this.currentType][e]=parseFloat(t),this.updatePreview(),console.log(`[MineObjectCreator] Updated ${e}: ${t}`))}createPreview(){this.removePreview();const e=this.parameters[this.currentType],t=this.createGeometry(this.currentType,e),i=this.createPreviewMaterial(this.currentType);this.previewObject=new f(t,i),this.previewObject.position.copy(this.currentPosition),this.previewObject.name="preview_object",this.scene.add(this.previewObject)}updatePreview(){if(this.previewObject){const e=this.parameters[this.currentType],t=this.createGeometry(this.currentType,e);this.previewObject.geometry.dispose(),this.previewObject.geometry=t}}removePreview(){this.previewObject&&(this.scene.remove(this.previewObject),this.previewObject.geometry.dispose(),this.previewObject.material.dispose(),this.previewObject=null)}createGeometry(e,t){let i;switch(t&&t.orientation&&(t.orientation==="yatay"?t.orientation="horizontal":t.orientation==="dikey"&&(t.orientation="vertical")),e){case"tunnel":t.orientation==="vertical"?(i=new B(t.width/2,t.width/2,t.length,16,1,!1),t.angle&&t.angle!==0&&i.rotateY(t.angle*Math.PI/180)):(i=new B(t.height/2,t.height/2,t.length,16,1,!1),t.angle&&t.angle!==0&&i.rotateY(t.angle*Math.PI/180),i.rotateX(Math.PI/2),i.scale(t.width/t.height,1,1));break;case"road":i=new j(t.width,t.height,t.length);break;case"rail":i=new j(t.width,t.height,t.length);break;case"conveyor":i=new j(t.width,t.height,t.length);break;default:i=new j(2,2,2)}return e!=="tunnel"&&t.angle&&t.angle!==0&&(t.orientation==="vertical"?i.rotateY(t.angle*Math.PI/180):i.rotateZ(t.angle*Math.PI/180)),i}createPreviewMaterial(e){const t={tunnel:8421504,road:4210752,rail:6710886,conveyor:16766720};return new X({color:t[e]||8421504,transparent:!0,opacity:.6,wireframe:!1})}finalizeCreation(){var o;if(!this.previewObject)return null;const e=this.parameters[this.currentType],t=this.createGeometry(this.currentType,e),i=this.createFinalMaterial(this.currentType),n=new f(t,i);if(n.position.copy(this.previewObject.position),n.userData={id:this.nextId++,type:this.currentType,parameters:{...e},selectable:!0},this.viewer&&this.viewer.collisionSystem){const s=Array.from(this.createdObjects.values()),a=this.viewer.collisionSystem.validateTunnelPlacement(n,s);if(!a.isValid){const h=`⚠️ Placement conflict detected!
${a.conflicts.length} collision(s) found.`;if(!confirm(`${h}

Do you want to place anyway?`))return n.geometry.dispose(),n.material.dispose(),null}}if(this.scene.add(n),this.createdObjects.set(n.userData.id,n),this.viewer&&this.viewer.collisionSystem&&this.viewer.collisionSystem.registerObject(n,"static",{type:this.currentType,creator:"MineObjectCreator",parameters:e}),this.viewer&&this.viewer.objectSelector){try{this.viewer.objectSelector.addSelectableObject(n,{id:n.userData.id,type:n.userData.type,name:`${n.userData.type.charAt(0).toUpperCase()+n.userData.type.slice(1)} ${n.userData.id}`,parameters:n.userData.parameters,color:"#"+n.material.color.getHexString()})}catch(s){console.warn("[MineObjectCreator] Selectable eklenemedi:",s)}this.currentType==="tunnel"&&setTimeout(()=>{this.viewer.createTunnelEndpoints(n,n.userData)},100)}if(this.removePreview(),console.log(`[MineObjectCreator] Created ${this.currentType} with ID: ${n.userData.id}`),this.autoMultiPlace)this.createPreview();else if(this.isCreating=!1,(o=this.hideCreationUI)==null||o.call(this),this.viewer&&(this.viewer.isCreatingMode=!1,typeof this.viewer.removePreview=="function"))try{this.viewer.removePreview()}catch{}return n}createFinalMaterial(e){const t={tunnel:8421504,road:4210752,rail:6710886,conveyor:16766720};return new X({color:t[e]||8421504,transparent:!1,opacity:1})}showCreationUI(){let e=document.getElementById("creation-panel");e||(e=this.createCreationPanel()),e.style.display="block",this.updateUIForType(this.currentType)}hideCreationUI(){const e=document.getElementById("creation-panel");e&&(e.style.display="none")}createCreationPanel(){const e=document.createElement("div");return e.id="creation-panel",e.className="creation-panel",e.style.cssText=`
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 20px;
            border-radius: 10px;
            min-width: 280px;
            z-index: 1000;
            display: none;
            font-family: Arial, sans-serif;
        `,e.innerHTML=`
            <h4 id="creation-title" style="margin-top: 0; color: #fff;">Tünel Oluştur</h4>
            
            <div class="parameter-group" style="margin-bottom: 15px;">
                <label for="param1" style="display: block; margin-bottom: 5px;">
                    Genişlik: <span id="param1-value" style="color: #4CAF50; font-weight: bold;">3</span>m
                </label>
                <input type="range" id="param1" min="1" max="10" step="0.5" value="3" 
                       style="width: 100%; margin-bottom: 5px;">
                <input type="number" id="param1-number" min="1" max="10" step="0.5" value="3"
                       style="width: 100%; padding: 4px; margin-bottom: 10px; background: #333; color: white; border: 1px solid #555; border-radius: 3px;">
                
                <label for="param2" style="display: block; margin-bottom: 5px;">
                    Yükseklik: <span id="param2-value" style="color: #4CAF50; font-weight: bold;">3</span>m
                </label>
                <input type="range" id="param2" min="1" max="8" step="0.5" value="3"
                       style="width: 100%; margin-bottom: 5px;">
                <input type="number" id="param2-number" min="1" max="8" step="0.5" value="3"
                       style="width: 100%; padding: 4px; margin-bottom: 10px; background: #333; color: white; border: 1px solid #555; border-radius: 3px;">
                
                <label for="param3" style="display: block; margin-bottom: 5px;">
                    Uzunluk: <span id="param3-value" style="color: #4CAF50; font-weight: bold;">10</span>m
                </label>
                <input type="range" id="param3" min="5" max="5000" step="1" value="10"
                       style="width: 100%; margin-bottom: 5px;">
                <input type="number" id="param3-number" min="5" max="5000" step="1" value="10"
                       style="width: 100%; padding: 4px; margin-bottom: 15px; background: #333; color: white; border: 1px solid #555; border-radius: 3px;">
            </div>
            
            <div id="tunnel-controls" class="tunnel-specific" style="margin-bottom: 15px; border-top: 1px solid #444; padding-top: 15px;">
                <label for="orientation" style="display: block; margin-bottom: 5px;">
                    Yönelim:
                </label>
                <select id="orientation" style="width: 100%; padding: 5px; margin-bottom: 10px; background: #333; color: white; border: 1px solid #555;">
                    <option value="horizontal">Yatay</option>
                    <option value="vertical">Dikey</option>
                </select>
                
                <label for="angle" style="display: block; margin-bottom: 5px;">
                    Açı: <span id="angle-value" style="color: #4CAF50; font-weight: bold;">0</span>°
                </label>
                <input type="range" id="angle" min="0" max="360" step="5" value="0"
                       style="width: 100%; margin-bottom: 10px;">
            </div>
            
            <div class="button-group" style="margin-top: 15px;">
                <button id="create-confirm" class="btn btn-success" 
                        style="background: #4CAF50; color: white; border: none; padding: 8px 16px; border-radius: 4px; margin-right: 10px; cursor: pointer;">
                    Oluştur
                </button>
                <button id="create-cancel" class="btn btn-secondary"
                        style="background: #666; color: white; border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer;">
                    İptal
                </button>
            </div>
        `,document.body.appendChild(e),this.setupCreationPanelEvents(),e}setupCreationPanelEvents(){const e=document.getElementById("param1"),t=document.getElementById("param2"),i=document.getElementById("param3"),n=document.getElementById("param1-number"),o=document.getElementById("param2-number"),s=document.getElementById("param3-number"),a=document.getElementById("orientation"),r=document.getElementById("angle"),h=document.getElementById("create-confirm"),l=document.getElementById("create-cancel");e.addEventListener("input",d=>{const c=d.target.value;document.getElementById("param1-value").textContent=c,n.value=c,this.updateParameter("width",c)}),t.addEventListener("input",d=>{const c=d.target.value;document.getElementById("param2-value").textContent=c,o.value=c,this.updateParameter("height",c)}),i.addEventListener("input",d=>{const c=d.target.value;document.getElementById("param3-value").textContent=c,s.value=c,this.updateParameter("length",c)}),n.addEventListener("input",d=>{const c=d.target.value;document.getElementById("param1-value").textContent=c,e.value=c,this.updateParameter("width",c)}),o.addEventListener("input",d=>{const c=d.target.value;document.getElementById("param2-value").textContent=c,t.value=c,this.updateParameter("height",c)}),s.addEventListener("input",d=>{const c=d.target.value;document.getElementById("param3-value").textContent=c,i.value=c,this.updateParameter("length",c)}),a.addEventListener("change",d=>{this.updateParameter("orientation",d.target.value)}),r.addEventListener("input",d=>{document.getElementById("angle-value").textContent=d.target.value,this.updateParameter("angle",d.target.value)}),h.addEventListener("click",()=>{const d=this.finalizeCreation();d&&(this.stopCreating(),this.viewer&&this.viewer.saveObjectToServer(d))}),l.addEventListener("click",()=>{this.stopCreating()})}updateUIForType(e){const t={tunnel:"Tünel Oluştur",road:"Yol Oluştur",rail:"Ray Oluştur",conveyor:"Konveyör Oluştur"};document.getElementById("creation-title").textContent=t[e]||"Obje Oluştur";const i=this.parameters[e];document.getElementById("param1").value=i.width,document.getElementById("param1-value").textContent=i.width,document.getElementById("param1-number").value=i.width,document.getElementById("param2").value=i.height,document.getElementById("param2-value").textContent=i.height,document.getElementById("param2-number").value=i.height,document.getElementById("param3").value=i.length,document.getElementById("param3-value").textContent=i.length,document.getElementById("param3-number").value=i.length;const n=document.getElementById("tunnel-controls");e==="tunnel"?(n.style.display="block",document.getElementById("orientation").value=i.orientation||"horizontal",document.getElementById("angle").value=i.angle||0,document.getElementById("angle-value").textContent=i.angle||0):n.style.display="none"}async saveToServer(e){var t,i,n;try{const o={mine_id:this.mineId||1,name:`${e.userData.type.charAt(0).toUpperCase()+e.userData.type.slice(1)} ${e.userData.id}`,type:"model",geometry:{type:e.userData.type,...e.userData.parameters},material:{color:e.material.color.getHex(),opacity:e.material.opacity||1},position:[e.position.x,e.position.y,e.position.z],rotation:[e.rotation.x,e.rotation.y,e.rotation.z],scale:[e.scale.x,e.scale.y,e.scale.z],properties:{createdAt:new Date().toISOString(),tool:e.userData.type},visible:!0,order:e.userData.id},s=await fetch(`/api/mines/${this.mineId||1}/models`,{method:"POST",headers:{"Content-Type":"application/json","X-CSRF-TOKEN":((t=document.querySelector('meta[name="csrf-token"]'))==null?void 0:t.getAttribute("content"))||"",Accept:"application/json"},body:JSON.stringify(o)});if(s.ok){const a=await s.json();e.userData.serverId=(i=a.data)==null?void 0:i.id,console.log("[MineObjectCreator] Successfully saved to server:",a)}else throw new Error(`HTTP ${s.status}: ${s.statusText}`)}catch(o){console.error("[MineObjectCreator] Error saving to server:",o),(n=this.showError)==null||n.call(this,"Obje kaydedilemedi: "+o.message)}}showError(e){const t=document.createElement("div");t.style.cssText=`
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: #ff4444;
            color: white;
            padding: 10px 20px;
            border-radius: 5px;
            z-index: 10000;
        `,t.textContent=e,document.body.appendChild(t),setTimeout(()=>{document.body.removeChild(t)},3e3)}}class Et{constructor(e,t,i){this.scene=e,this.camera=t,this.renderer=i,this.isDrawing=!1,this.currentPath=[],this.tempPath=null,this.paths=new Map,this.raycaster=new ie,this.mouse=new re,this.groundPlane=new Ie(new u(0,1,0),-2),this.tunnelConstraintMode=!1,this.constraintTunnel=null,this.currentDrawingType="tunnel",this.previewMesh=null,this.distanceLabel=null,this.drawingCallbacks={onPathStart:null,onPathUpdate:null,onPathComplete:null},this._lodFrame=0,this.debug=!1}startDrawing(e={}){this.stopDrawing(),this.isDrawing=!0,this.currentPath=[],this.drawingCallbacks={...this.drawingCallbacks,...e},console.log("[MinePathDrawer] Yol çizimi başladı - state temizlendi, type:",this.currentDrawingType)}setDrawingType(e){this.currentDrawingType=e,console.log("[MinePathDrawer] Drawing type set to:",e)}setAxisConstraint(e){this.axisConstraint=e,console.log("[MinePathDrawer] Axis constraint set to:",e)}stopDrawing(){this.isDrawing=!1,this.currentPath=[],this.removeTempPath(),this.removePreviewMesh(),this.removeDistanceLabel(),console.log("[MinePathDrawer] Yol çizimi durdu - temizlik yapıldı")}handleClick(e){if(!this.isDrawing)return;this.updateMousePosition(e);const t=this.getGroundIntersection();t&&(this.currentPath.push(t),this.updateTempPath(),this.drawingCallbacks.onPathUpdate&&this.drawingCallbacks.onPathUpdate(this.currentPath))}handleMouseMove(e){if(!this.isDrawing||this.currentPath.length===0)return;this.updateMousePosition(e);let t=this.getGroundIntersection();if(t){if(this.axisConstraint&&this.currentPath.length>0){const n=this.currentPath[this.currentPath.length-1];switch(this.axisConstraint){case"x":t.y=n.y,t.z=n.z;break;case"y":t.x=n.x,t.z=n.z;break;case"z":t.x=n.x,t.y=n.y;break}}this.viewer.constrainToAxis&&(t=this.viewer.constrainToAxis(t)),this.updatePreview(t);const i=[...this.currentPath,t];this.updateTempPath(i)}}updateMousePosition(e){const t=this.renderer.domElement.getBoundingClientRect();this.mouse.x=(e.clientX-t.left)/t.width*2-1,this.mouse.y=-((e.clientY-t.top)/t.height)*2+1}getGroundIntersection(){this.raycaster.setFromCamera(this.mouse,this.camera);const e=new u;if(this.tunnelConstraintMode&&this.constraintTunnel){const t=this.raycaster.intersectObject(this.constraintTunnel,!0);if(t.length>0){const i=t[0].point;return i.y=-2.5,this.debug&&console.log("[MinePathDrawer] Tunnel constraint intersection found:",{x:i.x.toFixed(2),y:i.y.toFixed(2),z:i.z.toFixed(2)}),i}else return this.debug&&console.log("[MinePathDrawer] No tunnel constraint intersection found"),null}else return this.raycaster.ray.intersectPlane(this.groundPlane,e)?(this.debug&&console.log("[MinePathDrawer] Ground intersection found:",{x:e.x.toFixed(2),y:e.y.toFixed(2),z:e.z.toFixed(2)}),e):(this.debug&&console.log("[MinePathDrawer] No ground intersection found"),null)}updateTempPath(e=null){this.removeTempPath();const t=e||this.currentPath;if(t.length<2)return;const i=new ae().setFromPoints(t),n=new J({color:16711680,linewidth:3,opacity:.8,transparent:!0});this.tempPath=new N(i,n),this.scene.add(this.tempPath)}removeTempPath(){this.tempPath&&(console.log("[MinePathDrawer] Removing temp path"),this.scene.remove(this.tempPath),this.tempPath.geometry.dispose(),this.tempPath.material.dispose(),this.tempPath=null)}completePath(){if(this.currentPath.length<2)return console.log("[MinePathDrawer] Complete path failed: not enough points"),null;console.log("[MinePathDrawer] Completing path with",this.currentPath.length,"points"),this.removeTempPath(),this.drawingCallbacks.onPathComplete&&this.drawingCallbacks.onPathComplete(this.currentPath);const e=[...this.currentPath];return this.currentPath=[],e}createPath(e){const{id:t,points:i,width:n=2.5,height:o=2.5,color:s="#808080",type:a="tunnel"}=e;if(!i||i.length<2)return null;const r=this.createPathMesh(i,n,o,s,a);if(r.userData={id:t,type:a,pathData:e},this.viewer&&this.viewer.collisionSystem){const h=Array.from(this.paths.values());let l=!1;h.forEach(d=>{var p;const c=this.viewer.collisionSystem.detectPathIntersections(r,d);c.length>0&&(l=!0,console.warn(`⚠️ Path intersection detected with path ${d.userData.id}:`,c),(p=this.viewer.options)!=null&&p.debugCollisions&&c.forEach(m=>{const y=new f(new oe(.2),new W({color:16711680}));y.position.copy(m.point),this.scene.add(y),setTimeout(()=>this.scene.remove(y),5e3)}))}),l&&console.log(`⚠️ Path ${t} has intersections with existing paths`),this.viewer.collisionSystem.registerObject(r,"static",{type:"path",pathType:a,points:i,width:n,height:o})}return this.paths.set(t,r),this.scene.add(r),a==="tunnel"&&this.viewer&&this.viewer.createTunnelEndpoints&&setTimeout(()=>{this.viewer.createTunnelEndpoints(r,e)},100),console.log(`[MinePathDrawer] Yol oluşturuldu: ${t}, boyutlar: ${n}x${o}`),r}createPathMesh(e,t,i,n,o){const s=new we,a=this.createTubeGeometry(e,t,i),r=this.createPathMaterial(n,o),h=new f(a,r);h.castShadow=!0,h.receiveShadow=!0;const l=this.createTubeGeometry(e,t,i,{quality:"low"});h.userData.highGeometry=a,h.userData.lowGeometry=l,h.userData.lodState="high",s.add(h);const d=new Ke(a),c=new J({color:new Z(n).multiplyScalar(.5),opacity:.6,transparent:!0,linewidth:1}),p=new Je(d,c);return s.add(p),o==="conveyor"?this.addConveyorBelt(s,e,t):o==="rail"&&this.addRailTracks(s,e,t),s}createPathMaterial(e,t){const i=new Z(e);switch(t){case"tunnel":return new X({color:i,transparent:!0,opacity:.9,shininess:30,specular:4473924});case"road":return new ve({color:i.multiplyScalar(.7),transparent:!0,opacity:.95});case"rail":return new X({color:i,metalness:.7,roughness:.3,transparent:!0,opacity:.9});case"conveyor":return new X({color:i,transparent:!0,opacity:.8,shininess:50,specular:8947848});default:return new ve({color:i,transparent:!0,opacity:.9})}}createTubeGeometry(e,t,i,n={}){if(e.length<2)return new j(1,1,1);const o=e.map(c=>c?c.isVector3?c:typeof c.x=="number"&&typeof c.y=="number"&&typeof c.z=="number"?new u(c.x,c.y,c.z):(console.warn("[createTubeGeometry] Unexpected point format, coercing to (0,0,0):",c),new u):new u),s=new ne(o);s.tension=.2;const a=Math.max(e.length*6,24);let r=a;n.quality==="low"&&(r=Math.max(Math.floor(a*.35),8)),r=Math.min(r,360);const h=n.quality==="low"?8:16,l=new se(s,r,Math.max(t,i)/2,h,!1),d=l.attributes.position.array;for(let c=0;c<d.length;c+=3){const p=d[c],m=d[c+1],y=d[c+2];if(Math.sqrt(p*p+y*y)>0){const S=Math.atan2(y,p),g=t*i/Math.sqrt((i*Math.cos(S))**2+(t*Math.sin(S))**2)/(Math.max(t,i)/2);d[c]=p*g,d[c+2]=y*g,m<0&&(d[c+1]=m*.8)}}return l.attributes.position.needsUpdate=!0,l.computeVertexNormals(),l}updateLOD(){if(this._lodFrame++,this._lodFrame%10===0)for(const[,e]of this.paths){if(!e)continue;const t=e.children.find(s=>s.isMesh);if(!t||!t.userData.highGeometry)continue;t.userData._bs||(t.userData.highGeometry.computeBoundingSphere(),t.userData._bs=t.userData.highGeometry.boundingSphere.clone());const i=t.userData._bs.center.clone();e.localToWorld(i);const o=i.distanceTo(this.camera.position)>180?"low":"high";o!==t.userData.lodState&&(o==="low"?(t.geometry=t.userData.lowGeometry,t.userData.lodState="low"):(t.geometry=t.userData.highGeometry,t.userData.lodState="high"))}}addConveyorBelt(e,t,i){const n=new ne(t),o=new se(n,t.length*2,i/3,8,!1),s=new X({color:3355443,shininess:100,transparent:!0,opacity:.8}),a=new f(o,s);a.position.y+=.1,e.add(a)}addRailTracks(e,t,i){const n=new ne(t),o=new se(n,t.length*4,.05,6,!1),s=new X({color:6710886,metalness:.8,roughness:.2}),a=new f(o,s.clone());a.position.x-=i/3,a.position.y+=.05,e.add(a);const r=new f(o.clone(),s.clone());r.position.x+=i/3,r.position.y+=.05,e.add(r)}removePath(e){const t=this.paths.get(e);t&&(this.scene.remove(t),t.traverse(i=>{i.geometry&&i.geometry.dispose(),i.material&&(Array.isArray(i.material)?i.material.forEach(n=>n.dispose()):i.material.dispose())}),this.paths.delete(e),console.log(`[MinePathDrawer] Yol silindi: ${e}`))}clearAllPaths(){for(const[e,t]of this.paths)this.removePath(e);console.log("[MinePathDrawer] Tüm yollar silindi")}getPath(e){return this.paths.get(e)}getAllPaths(){return Array.from(this.paths.values())}calculatePathLength(e){if(!e||e.length<2)return 0;let t=0;for(let i=1;i<e.length;i++){const n=e[i-1],o=e[i],s=o.x-n.x,a=o.y-n.y,r=o.z-n.z;t+=Math.sqrt(s*s+a*a+r*r)}return t}enableTunnelConstraint(e){this.tunnelConstraintMode=!0,this.constraintTunnel=e,console.log("[MinePathDrawer] Tunnel constraint mode enabled")}disableTunnelConstraint(){this.tunnelConstraintMode=!1,this.constraintTunnel=null,console.log("[MinePathDrawer] Tunnel constraint mode disabled")}updatePreview(e){if(!this.isDrawing||this.currentPath.length===0)return;const t=[...this.currentPath,e];this.createPreviewMesh(t),this.updateDistanceLabel(e)}createPreviewMesh(e){if(this.removePreviewMesh(),e.length<2)return;let t,i;switch(this.currentDrawingType){case"tunnel":t=this.createTubeGeometry(e,2.5,2.5),i=new W({color:6710886,transparent:!0,opacity:.3,wireframe:!0});break;case"road":t=this.createRoadGeometry(e,3),i=new W({color:3355443,transparent:!0,opacity:.4});break;case"rail":t=this.createRailGeometry(e,1.5),i=new W({color:6710886,transparent:!0,opacity:.5});break;case"conveyor":t=this.createConveyorGeometry(e,1),i=new W({color:4473924,transparent:!0,opacity:.4});break;default:t=new ae().setFromPoints(e),i=new J({color:16711680,transparent:!0,opacity:.7})}this.currentDrawingType==="tunnel"||this.currentDrawingType==="road"||this.currentDrawingType==="rail"||this.currentDrawingType==="conveyor"?this.previewMesh=new f(t,i):this.previewMesh=new N(t,i),this.scene.add(this.previewMesh)}removePreviewMesh(){this.previewMesh&&(this.scene.remove(this.previewMesh),this.previewMesh.geometry&&this.previewMesh.geometry.dispose(),this.previewMesh.material&&this.previewMesh.material.dispose(),this.previewMesh=null)}updateDistanceLabel(e){if(this.currentPath.length===0)return;const i=this.currentPath[this.currentPath.length-1].distanceTo(e);this.updateDistanceDisplay(i)}updateDistanceDisplay(e){const t=document.getElementById("distance-display"),i=document.getElementById("distance-value");t&&i&&(t.style.display="block",i.textContent=`${e.toFixed(1)}m`)}removeDistanceLabel(){const e=document.getElementById("distance-display");e&&(e.style.display="none")}createRoadGeometry(e,t){const i=new ne(e);return new se(i,e.length*2,t/2,8,!1)}createRailGeometry(e,t){const i=new ne(e);return new se(i,e.length*2,.1,6,!1)}createConveyorGeometry(e,t){const i=new ne(e);return new se(i,e.length*2,t/2,6,!1)}}class Pt{constructor(e,t,i,n){this.scene=e,this.camera=t,this.renderer=i,this.pathDrawer=n,this.raycaster=new ie,this.mouse=new re,this.isEditing=!1,this.activePath=null,this.handles=[],this.draggingHandle=null,this.dragPlane=new Ie(new u(0,1,0),0),this.offset=new u,this.intersection=new u,this.callbacks={onPointChange:null,onEditStart:null,onEditEnd:null},this.undoStack=[],this.redoStack=[],this.maxHistory=50}setCallbacks(e){this.callbacks={...this.callbacks,...e}}startEditing(e){if(!e||!e.userData||!e.userData.pathData)return;this.stopEditing(),this.isEditing=!0,this.activePath=e;const t=e.userData.pathData,i=(t.points||t.path_points||[]).map(o=>({...o}));this.undoStack=[i],this.redoStack=[],this.buildHandles(),this.callbacks.onEditStart&&this.callbacks.onEditStart(e);const n=document.getElementById("save-path-btn");n&&(n.disabled=!1)}stopEditing(){this.clearHandles(),this.isEditing=!1,this.activePath=null,this.draggingHandle=null,this.callbacks.onEditEnd&&this.callbacks.onEditEnd();const e=document.getElementById("save-path-btn");e&&(e.disabled=!0)}buildHandles(){this.clearHandles();const e=this.activePath.userData.pathData,t=e.points||e.path_points||[],i=new oe(.6,12,12),n=new W({color:16763904});t.forEach((o,s)=>{const a=new f(i.clone(),n.clone());a.position.set(o.x,o.y,o.z),a.userData.isPathHandle=!0,a.userData.pointIndex=s,this.scene.add(a),this.handles.push({mesh:a,index:s})})}clearHandles(){this.handles.forEach(e=>{this.scene.remove(e.mesh),e.mesh.geometry.dispose(),e.mesh.material.dispose()}),this.handles=[]}updateMouse(e){const t=this.renderer.domElement.getBoundingClientRect();this.mouse.x=(e.clientX-t.left)/t.width*2-1,this.mouse.y=-((e.clientY-t.top)/t.height)*2+1}pointerDown(e){if(!this.isEditing)return;this.updateMouse(e),this.raycaster.setFromCamera(this.mouse,this.camera);const t=this.raycaster.intersectObjects(this.handles.map(i=>i.mesh),!0);if(t.length>0){const i=t[0].object;this.draggingHandle=this.handles.find(n=>n.mesh===i),this.dragPlane.set(new u(0,1,0),-i.position.y)}}pointerMove(e){if(!this.isEditing||!this.draggingHandle)return;this.updateMouse(e),this.raycaster.setFromCamera(this.mouse,this.camera);const t=new u;if(this.raycaster.ray.intersectPlane(this.dragPlane,t)){const i=this.draggingHandle;t.y=-2.5,i.mesh.position.copy(t),this.applyHandlePosition(i.index,t,{skipHistory:!0,skipDirty:!0})}}pointerUp(){var e;if(this.isEditing){if(this.draggingHandle){const t=(e=this.activePath)==null?void 0:e.userData.pathData;t&&t.points&&(this.pushHistory(t.points),this.viewer&&this.viewer.markPathDirty(t.id||t.path_id||this.activePath.userData.id))}this.draggingHandle=null}}applyHandlePosition(e,t,i={}){if(!this.activePath)return;const n=this.activePath.userData.pathData,o=n.points||n.path_points||[];if(!o[e])return;o[e]={x:t.x,y:t.y,z:t.z};const s=this.viewer&&this.viewer.pathSimplifyMultiplier?this.viewer.pathSimplifyMultiplier:1,a=Tt(o,s),r=Ct(o,a);this.rebuildPath(r,n),this.callbacks.onPointChange&&this.callbacks.onPointChange(r,n),i.skipHistory||this.pushHistory(r),!i.skipDirty&&this.viewer&&this.viewer.markPathDirty(n.id||n.path_id||this.activePath.userData.id)}pushHistory(e){const t=e.map(n=>({...n})),i=this.undoStack[this.undoStack.length-1];i&&i.length===t.length&&i.every((n,o)=>n.x===t[o].x&&n.y===t[o].y&&n.z===t[o].z)||(this.undoStack.push(t),this.undoStack.length>this.maxHistory&&this.undoStack.shift(),this.redoStack=[])}undo(){if(this.undoStack.length<=1)return;const e=this.undoStack.pop();this.redoStack.push(e);const t=this.undoStack[this.undoStack.length-1];this.applyHistoryState(t)}redo(){if(this.redoStack.length===0)return;const e=this.redoStack.pop();this.undoStack.push(e),this.applyHistoryState(e)}applyHistoryState(e){if(!this.activePath)return;const t=this.activePath.userData.pathData;this.rebuildPath(e,t),this.callbacks.onPointChange&&this.callbacks.onPointChange(e,t),this.clearHandles(),this.buildHandles()}rebuildPath(e,t){const i=this.activePath;[...i.children].forEach(l=>{i.remove(l),l.geometry&&l.geometry.dispose(),l.userData&&(l.userData.lowGeometry&&l.userData.lowGeometry!==l.geometry&&(l.userData.lowGeometry.dispose(),l.userData.lowGeometry=null),l.userData.highGeometry&&l.userData.highGeometry!==l.geometry&&(l.userData.highGeometry!==l.geometry&&l.userData.highGeometry.dispose(),l.userData.highGeometry=null)),l.material&&(Array.isArray(l.material)?l.material.forEach(d=>d.dispose()):l.material.dispose())});const o=t.width||2.5,s=t.height||2.5,a=t.color||"#808080",r=t.type||"tunnel";this.pathDrawer.createPathMesh(e.map(l=>new u(l.x,l.y,l.z)),o,s,a,r).children.forEach(l=>i.add(l)),t.points=e,t.path_points=e,this.clearHandles(),this.buildHandles(),i.traverse(l=>{l.userData&&l.userData._bs&&(l.userData._bs=null)})}}function Ct(M,e){if(!M||M.length<3)return M;const t=e*e;function i(s,a,r){let h=a.x,l=a.y,d=a.z,c=r.x-h,p=r.y-l,m=r.z-d;if(c!==0||p!==0||m!==0){let y=((s.x-h)*c+(s.y-l)*p+(s.z-d)*m)/(c*c+p*p+m*m);y>1?(h=r.x,l=r.y,d=r.z):y>0&&(h+=c*y,l+=p*y,d+=m*y)}return c=s.x-h,p=s.y-l,m=s.z-d,c*c+p*p+m*m}function n(s,a,r,h,l){let d=h,c=-1;for(let p=a+1;p<r;p++){const m=i(s[p],s[a],s[r]);m>d&&(c=p,d=m)}d>h&&c!==-1&&(c-a>1&&n(s,a,c,h,l),l.push(s[c]),r-c>1&&n(s,c,r,h,l))}const o=[M[0]];return n(M,0,M.length-1,t,o),o.push(M[M.length-1]),o}function Tt(M,e=1){if(!M||M.length<3)return .05*e;let t=0;for(let l=1;l<M.length;l++){const d=M[l].x-M[l-1].x,c=M[l].y-M[l-1].y,p=M[l].z-M[l-1].z;t+=Math.sqrt(d*d+c*c+p*p)}let i=0,n=0;for(let l=1;l<M.length-1;l++){const d=M[l-1],c=M[l],p=M[l+1],m=c.x-d.x,y=c.y-d.y,D=c.z-d.z,S=p.x-c.x,w=p.y-c.y,g=p.z-c.z,b=Math.sqrt(m*m+y*y+D*D)+1e-6,x=Math.sqrt(S*S+w*w+g*g)+1e-6,v=(m*S+y*w+D*g)/(b*x),E=Math.acos(Math.min(1,Math.max(-1,v)));i+=E,n++}const o=n?i/n:0,s=Math.min(1,t/500),a=1-Math.min(1,o/.8),h=(.05+.4*s*a)*e;return Math.min(1,Math.max(.02,h))}class zt{constructor(e,t,i){this.scene=e,this.camera=t,this.renderer=i,this.raycaster=new ie,this.mouse=new re,this.selectedObject=null,this.multiSelect=!0,this.selectedObjects=new Set,this.selectableObjects=new Set,this.highlightMaterial=new W({color:16729156,transparent:!0,opacity:.3,depthTest:!1}),this.outlineColor=16711680,this.xrayModeObject=null,this.originalMaterials=new Map,this.callbacks={onObjectSelect:null,onObjectDeselect:null,onObjectDelete:null}}setCallbacks(e){this.callbacks={...this.callbacks,...e}}addSelectableObject(e,t={}){e.userData.selectable=!0,e.userData.objectData=t,this.selectableObjects.add(e)}removeSelectableObject(e){this.selectableObjects.delete(e),this.selectedObject===e&&this.deselectObject()}handleClick(e){this.updateMousePosition(e),this.raycaster.setFromCamera(this.mouse,this.camera);const t=Array.from(this.selectableObjects),i=this.raycaster.intersectObjects(t,!0);if(i.length>0){let n=null;for(const o of i){let s=o.object;for(;s&&!s.userData.selectable;)s=s.parent;if(s&&this.selectableObjects.has(s)){n=s;break}}if(n){const o=e.shiftKey;this.multiSelect&&o?this.selectedObjects.has(n)?this.deselectObject(n):this.addToSelection(n):(this.clearMultiSelection(),this.selectObject(n))}}else this.clearMultiSelection(),this.deselectObject()}updateMousePosition(e){const t=this.renderer.domElement.getBoundingClientRect();this.mouse.x=(e.clientX-t.left)/t.width*2-1,this.mouse.y=-((e.clientY-t.top)/t.height)*2+1}selectObject(e){if(this.selectedObject===e){e.userData.objectData&&e.userData.objectData.pathType==="tunnel"&&this.toggleXRayMode(e);return}this.deselectObject(),this.selectedObject=e,this.selectedObjects.add(e),this.addHighlight(e),e.userData.objectData&&e.userData.objectData.pathType==="tunnel"&&this.enableXRayMode(e),this.callbacks.onObjectSelect&&this.callbacks.onObjectSelect(e,e.userData.objectData)}deselectObject(){this.selectedObject&&(this.removeHighlight(this.selectedObject),this.disableXRayMode(),this.callbacks.onObjectDeselect&&this.callbacks.onObjectDeselect(this.selectedObject),this.selectedObject=null)}deleteSelectedObject(){if(this.selectedObject){const e=this.selectedObject;this.deselectObject(),this.callbacks.onObjectDelete&&this.callbacks.onObjectDelete(e)}}addHighlight(e){e.traverse(t=>{if(t.isMesh&&t.geometry){const i=new Ke(t.geometry),n=new Je(i,new J({color:this.outlineColor,linewidth:3}));n.name="highlight_outline",t.add(n)}})}removeHighlight(e){e.traverse(t=>{const i=t.getObjectByName("highlight_outline");i&&(t.remove(i),i.geometry.dispose(),i.material.dispose())})}deselectObject(e=null){if(e){this.removeHighlight(e),this.xrayModeObject===e&&this.disableXRayMode(),this.selectedObjects.delete(e),this.selectedObject===e&&(this.selectedObject=null),this.callbacks.onObjectDeselect&&this.callbacks.onObjectDeselect(e);return}this.selectedObject&&(this.removeHighlight(this.selectedObject),this.xrayModeObject===this.selectedObject&&this.disableXRayMode(),this.callbacks.onObjectDeselect&&this.callbacks.onObjectDeselect(this.selectedObject)),this.selectedObject=null,this.selectedObjects.clear()}addToSelection(e){this.selectedObjects.has(e)||(this.selectedObjects.add(e),this.addHighlight(e),this.callbacks.onObjectSelect&&this.callbacks.onObjectSelect(e,e.userData.objectData))}clearMultiSelection(){if(this.selectedObjects.size>1){for(const e of this.selectedObjects)e!==this.selectedObject&&this.removeHighlight(e);this.selectedObjects=this.selectedObject?new Set([this.selectedObject]):new Set}}enableXRayMode(e){this.xrayModeObject!==e&&(this.disableXRayMode(),this.xrayModeObject=e,e.traverse(t=>{if(t.isMesh){this.originalMaterials.set(t,t.material.clone());const i=t.material.clone();i.transparent=!0,i.opacity=.3,i.side=ke,t.material=i}}),console.log("[ObjectSelector] X-Ray mode enabled for tunnel"))}disableXRayMode(){this.xrayModeObject&&(this.xrayModeObject.traverse(e=>{e.isMesh&&this.originalMaterials.has(e)&&(e.material.dispose(),e.material=this.originalMaterials.get(e),this.originalMaterials.delete(e))}),this.xrayModeObject=null,console.log("[ObjectSelector] X-Ray mode disabled"))}toggleXRayMode(e){this.xrayModeObject===e?this.disableXRayMode():this.enableXRayMode(e)}}class kt{constructor(e,t,i={}){if(console.log("%c[SimpleMine3DViewer] Constructor called","color: blue; font-weight: bold;"),console.log("[SimpleMine3DViewer] Parameters:",{containerId:e,mineId:t,options:i}),this.containerId=e,this.mineId=t,this.container=document.getElementById(e),this.options={enableWebGL2:!0,enableCollisionDetection:!0,enableAdvancedShaders:!0,debugCollisions:!1,debugPerformance:!1,...i},this.actionHistory={undo:[],redo:[]},this.mergePersistEndpoint=i.mergePersistEndpoint||`/api/mines/${t}/merge-connections`,this.enableMergePersistence=i.enableMergePersistence??!1,this.orientationAnimations=[],console.log("[SimpleMine3DViewer] Container element:",this.container),!this.container){const n=`Container with id "${e}" not found`;throw console.error("[SimpleMine3DViewer]",n),new Error(n)}console.log("[SimpleMine3DViewer] THREE.js (ESM) version:",at),this.scene=null,this.camera=null,this.renderer=null,this.controls=null,this.webgl2Renderer=null,this.collisionSystem=null,this.shaderManager=null,this.performanceMonitor=null,this.pathDrawer=null,this.pathEditor=null,this.objectCreator=null,this.transformControls=null,this.isPathDrawingMode=!1,this.isCreatingMode=!1,this.selectedObject=null,this.objectSelector=null,this.endpointIndicators=new Map,this.showEndpoints=!0,console.log("[SimpleMine3DViewer] Starting initialization..."),this._dirtyPaths=new Set,this._dirtyIndicatorEl=null,this.measurementsEnabled=!0,this.measurementStep=5,this._lastMeasuredTunnel=null,this.autoSaveSelection=!0,this.autoSaveDelay=800,this._autoSaveTimer=null,this._autoSaveInFlight=!1,this.init()}_getSelEls(){return this._selCache||(this._selCache={card:document.getElementById("selection-detail-card"),title:document.getElementById("sel-title"),meta:document.getElementById("sel-meta"),dyn:document.getElementById("sel-dynamic-fields"),gen:document.getElementById("sel-generic-fields"),status:document.getElementById("sel-status"),saveBtn:document.getElementById("sel-save-btn"),deleteBtn:document.getElementById("sel-delete-btn"),closeBtn:document.getElementById("sel-close-btn")},this._selCache.closeBtn&&this._selCache.closeBtn.addEventListener("click",()=>this.hideSelectionCard()),this._selCache.deleteBtn&&this._selCache.deleteBtn.addEventListener("click",()=>{var e;if(this.selectedObject&&confirm("Seçili nesneyi silmek istiyor musunuz?")){const t=this.selectedObject.userData.objectData||this.selectedObject.userData;t&&t.type==="path"?(e=this.objectSelector)==null||e.deleteSelectedObject():this.deleteSelectedObject()}}),this._selCache.saveBtn&&this._selCache.saveBtn.addEventListener("click",()=>this.saveSelectionEdits())),this._selCache}showSelectionCard(e,t){const i=this._getSelEls();i.card&&(i.card.style.display="block",this.populateSelectionCard(e,t))}hideSelectionCard(){const e=this._getSelEls();e.card&&(e.card.style.display="none")}markSelectionDirty(e=!0){const t=this._getSelEls();t.saveBtn&&(e?(t.saveBtn.disabled=!1,t.saveBtn.classList.add("btn-warning"),this.autoSaveSelection&&(clearTimeout(this._autoSaveTimer),this._autoSaveTimer=setTimeout(async()=>{if(!this._autoSaveInFlight){this._autoSaveInFlight=!0;try{await this.saveSelectionEdits()}catch(i){console.warn("[AutoSave] Selection auto-save failed:",i.message)}finally{this._autoSaveInFlight=!1}}},this.autoSaveDelay))):(t.saveBtn.disabled=!0,t.saveBtn.classList.remove("btn-warning")))}populateSelectionCard(e,t){var a,r;const i=this._getSelEls();if(!i.card)return;t=t||((a=e==null?void 0:e.userData)==null?void 0:a.objectData)||(e==null?void 0:e.userData)||{};const n=t.type==="path",o=t.type==="tunnel"||t.pathType==="tunnel";if(i.title&&(i.title.innerHTML=`<i class="fas fa-cube me-1"></i>${t.name||"Obje"}${n?' <span class="badge bg-info ms-1">Path</span>':""}`),i.meta&&(i.meta.innerHTML=`ID: <span class="text-light">${t.id??"-"}</span> · Tip: <span class="text-light">${t.pathType||t.type||"-"}</span>`),i.dyn){let h="";if(n)h+=this._buildNumberField("Genişlik (m)","sel-width",t.width,.1,100,.1),h+=this._buildNumberField("Yükseklik (m)","sel-height",t.height,.1,100,.1),h+=`<div class="mb-2"><label class="form-label mb-1">Segment Sayısı</label><div class="form-control form-control-sm bg-dark text-light">${(t.points||[]).length}</div></div>`,h+=`<div class="mb-2"><label class="form-label mb-1">Uzunluk</label><div class="form-control form-control-sm bg-dark text-light">${(t.length||0).toFixed(2)} m</div></div>`,h+=this._buildColorField("Renk","sel-color",t.color||"#808080");else if(o&&((r=e==null?void 0:e.userData)!=null&&r.parameters)){const l=e.userData.parameters;h+=this._buildNumberField("Genişlik (m)","sel-width",l.width,.5,50,.1),h+=this._buildNumberField("Yükseklik (m)","sel-height",l.height,.5,50,.1),h+=this._buildNumberField("Uzunluk (m)","sel-length",l.length,1,1e4,.5),h+=this._buildSelectField("Yön","sel-orientation",["yatay","dikey"],l.orientation),h+=this._buildNumberField("Açı (°)","sel-angle",l.angle||0,0,360,1),h+=this._buildColorField("Renk","sel-color",t.color||"#808080"),h+=this._buildNumberField("Ölçüm Adımı (m)","sel-meas-step",this.measurementStep,1,100,1),h+=`
                    <div class="tunnel-merge-section" style="margin-top: 20px; padding: 15px; border: 1px solid #444; border-radius: 5px; background: rgba(255,255,255,0.05);">
                        <h6 style="color: #4CAF50; margin-bottom: 10px;"><i class="fas fa-link"></i> Tünel Birleştirme</h6>
                        <button id="start-tunnel-merge" class="btn btn-sm btn-outline-success" style="width: 100%; margin-bottom: 10px;">
                            <i class="fas fa-plus-circle"></i> Tünel Birleştirmeyi Başlat
                        </button>
                        <div id="tunnel-merge-ui" style="display: none;">
                            <div class="mb-2">
                                <label class="form-label mb-1" style="font-size: 12px;">Bu Tünelin Ucu:</label>
                                <select id="current-tunnel-endpoint" class="form-select form-select-sm bg-dark text-light">
                                    <option value="A">A Ucu (Başlangıç)</option>
                                    <option value="B">B Ucu (Bitiş)</option>
                                </select>
                            </div>
                            <div class="mb-2">
                                <label class="form-label mb-1" style="font-size: 12px;">Hedef Tünel:</label>
                                <select id="target-tunnel-select" class="form-select form-select-sm bg-dark text-light">
                                    <option value="">Tünel seçin...</option>
                                </select>
                            </div>
                            <div class="mb-2">
                                <label class="form-label mb-1" style="font-size: 12px;">Hedef Tünelin Ucu:</label>
                                <select id="target-tunnel-endpoint" class="form-select form-select-sm bg-dark text-light">
                                    <option value="A">A Ucu (Başlangıç)</option>
                                    <option value="B">B Ucu (Bitiş)</option>
                                </select>
                            </div>
                            <div class="btn-group" style="width: 100%; margin-top: 10px;">
                                <button id="execute-tunnel-merge" class="btn btn-sm btn-success" style="flex: 1;">
                                    <i class="fas fa-check"></i> Birleştir
                                </button>
                                <button id="cancel-tunnel-merge" class="btn btn-sm btn-secondary" style="flex: 1;">
                                    <i class="fas fa-times"></i> İptal
                                </button>
                            </div>
                        </div>
                    </div>
                `}else h+='<div class="text-muted small">Bu obje için düzenlenebilir alan yok.</div>';i.dyn.innerHTML=h}i.gen&&(i.gen.innerHTML=`<div class="mb-2"><label class="form-label mb-1">Pozisyon</label><div class="form-control form-control-sm bg-dark text-light">${e.position.x.toFixed(2)}, ${e.position.y.toFixed(2)}, ${e.position.z.toFixed(2)}</div></div>`),["sel-width","sel-height","sel-length","sel-angle","sel-orientation","sel-color"].forEach(h=>{const l=document.getElementById(h);l&&l.addEventListener("input",()=>{this.markSelectionDirty(!0),this._liveSelectionChange(h)})});const s=document.getElementById("sel-meas-step");s&&s.addEventListener("input",()=>{const h=parseInt(s.value,10);!isNaN(h)&&h>0&&(this.measurementStep=h,o&&this.buildTunnelMeasurements(e,t))}),o&&this.setupTunnelMergeEvents(e,t),this.markSelectionDirty(!1),i.status&&(i.status.textContent="")}_liveSelectionChange(e){if(!this.selectedObject)return;const t=this.selectedObject.userData&&(this.selectedObject.userData.objectData||this.selectedObject.userData)||{},i=t.type==="path",n=t.type==="tunnel"||t.pathType==="tunnel";if(i){const o=this.selectedObject,s=document.getElementById("sel-width"),a=document.getElementById("sel-height"),r=document.getElementById("sel-color"),h=parseFloat(s==null?void 0:s.value),l=parseFloat(a==null?void 0:a.value),d=r==null?void 0:r.value,c=o.userData.objectData||t;let p=!1;if(!isNaN(h)&&h>0&&h!==c.width&&(c.width=h,p=!0),!isNaN(l)&&l>0&&l!==c.height&&(c.height=l,p=!0),d&&d!==c.color&&(c.color=d,p=!0),p){const m=(c.points||c.path_points||[]).map(y=>new u(y.x,y.y,y.z));if(m.length>=2&&this.pathDrawer){const y=c.width||2.5,D=c.height||2.5,S=c.color||"#808080",w=c.pathType||c.type||"tunnel";if(!(this.pathEditor&&this.pathEditor.isEditing&&this.pathEditor.activePath===o)){for(;o.children.length;){const x=o.children.pop();x.geometry&&x.geometry.dispose(),x.material&&(Array.isArray(x.material)?x.material.forEach(v=>v.dispose()):x.material.dispose()),o.remove(x)}this.pathDrawer.createPathMesh(m,y,D,S,w).children.forEach(x=>o.add(x)),c.length=this.pathDrawer.calculatePathLength(m.map(x=>({x:x.x,y:x.y,z:x.z})));const b=document.getElementById("sel-dynamic-fields");b&&b.innerHTML.includes("Uzunluk")&&b.querySelectorAll("div")}}}}else if(n){const o={...this.selectedObject.userData.parameters||{}},s=document.getElementById("sel-width"),a=document.getElementById("sel-height"),r=document.getElementById("sel-length"),h=document.getElementById("sel-angle"),l=document.getElementById("sel-orientation"),d=document.getElementById("sel-color");let c=!1,p=!1;if(s&&!isNaN(parseFloat(s.value))&&parseFloat(s.value)!==o.width&&(o.width=parseFloat(s.value),c=!0),a&&!isNaN(parseFloat(a.value))&&parseFloat(a.value)!==o.height&&(o.height=parseFloat(a.value),c=!0),r&&!isNaN(parseFloat(r.value))&&parseFloat(r.value)!==o.length&&(o.length=parseFloat(r.value),c=!0),h&&!isNaN(parseFloat(h.value))&&parseFloat(h.value)!==o.angle&&(o.angle=parseFloat(h.value),c=!0),l&&l.value&&l.value!==o.orientation&&(p=!0,o.orientation=l.value,c=!0),d&&d.value&&this.selectedObject.material&&"#"+this.selectedObject.material.color.getHexString()!==d.value&&this.selectedObject.material.color.set(d.value),c&&(this.replaceTunnelGeometry(this.selectedObject,o),p&&this.camera&&this.controls)){const m=this.selectedObject.position.clone(),y=this.camera.position.distanceTo(m);let D;o.orientation==="dikey"||o.orientation==="vertical"?D=new u(m.x+y*.6,m.y+y*.8,m.z+y*.3):D=new u(m.x+y*.6,m.y+y*.3,m.z+y*.8);const S=this.camera.position.clone(),w=performance.now(),g=650,b=x=>{const v=Math.min(1,(x-w)/g),E=v<.5?2*v*v:-1+(4-2*v)*v;this.camera.position.lerpVectors(S,D,E),this.controls.target.lerpVectors(this.controls.target.clone(),m,E),v<1?requestAnimationFrame(b):this.controls.update()};requestAnimationFrame(b)}}}_buildNumberField(e,t,i,n,o,s){return i==null&&(i=""),`<div class="mb-2"><label class="form-label mb-1" for="${t}">${e}</label><input type="number" class="form-control form-control-sm bg-dark text-light" id="${t}" value="${i}" min="${n}" max="${o}" step="${s}"></div>`}_buildColorField(e,t,i){return`<div class="mb-2"><label class="form-label mb-1" for="${t}">${e}</label><input type="color" class="form-control form-control-color form-control-sm p-0 bg-dark border-0" id="${t}" value="${i}" title="Renk seç"></div>`}_buildSelectField(e,t,i,n){let o=a=>a;if(t==="sel-orientation"){const a={horizontal:"Yatay",vertical:"Dikey",yatay:"Yatay",dikey:"Dikey"};o=r=>a[r]||r,n==="horizontal"&&(n="yatay"),n==="vertical"&&(n="dikey"),i=i.map(r=>r==="horizontal"?"yatay":r==="vertical"?"dikey":r)}const s=i.map(a=>`<option value="${a}" ${a===n?"selected":""}>${o(a)}</option>`).join("");return`<div class="mb-2"><label class="form-label mb-1" for="${t}">${e}</label><select class="form-select form-select-sm bg-dark text-light" id="${t}">${s}</select></div>`}async saveSelectionEdits(){var n,o,s,a,r,h,l,d,c,p;const e=this._getSelEls();if(!this.selectedObject||!e.saveBtn)return;const t=this.selectedObject.userData.objectData||this.selectedObject.userData||{},i=t.type==="path";try{if(i){const m={},y=parseFloat((n=document.getElementById("sel-width"))==null?void 0:n.value),D=parseFloat((o=document.getElementById("sel-height"))==null?void 0:o.value),S=(s=document.getElementById("sel-color"))==null?void 0:s.value;isNaN(y)||(m.width=y),isNaN(D)||(m.height=D),S&&(m.color=S),await this.updatePathToServer(t.id,m)}else if((t.type==="tunnel"||t.pathType==="tunnel")&&this.selectedObject.userData.serverId){const m={...this.selectedObject.userData.parameters},y=parseFloat((a=document.getElementById("sel-width"))==null?void 0:a.value),D=parseFloat((r=document.getElementById("sel-height"))==null?void 0:r.value),S=parseFloat((h=document.getElementById("sel-length"))==null?void 0:h.value),w=parseFloat((l=document.getElementById("sel-angle"))==null?void 0:l.value),g=(d=document.getElementById("sel-orientation"))==null?void 0:d.value,b=(c=document.getElementById("sel-color"))==null?void 0:c.value;isNaN(y)||(m.width=y),isNaN(D)||(m.height=D),isNaN(S)||(m.length=S),isNaN(w)||(m.angle=w),g&&(m.orientation=g),b&&this.selectedObject.material&&this.selectedObject.material.color.set(b),this.replaceTunnelGeometry(this.selectedObject,m),await fetch(`/api/mines/${this.mineId}/models/${this.selectedObject.userData.serverId}`,{method:"PUT",headers:{"Content-Type":"application/json",Accept:"application/json","X-CSRF-TOKEN":((p=document.querySelector('meta[name="csrf-token"]'))==null?void 0:p.getAttribute("content"))||""},body:JSON.stringify({geometry:{type:"tunnel",params:m}})})}e.status&&(e.status.textContent="Kaydedildi"),this.markSelectionDirty(!1),setTimeout(()=>{this.deselectObject(),console.log("[SimpleMine3DViewer] Selection edits saved and object deselected")},500)}catch(m){console.error("Selection save error",m),e.status&&(e.status.style.color="#ff6b6b",e.status.textContent="Kaydetme hatası")}}async init(){var e,t;try{console.log("%c[SimpleMine3DViewer] Initializing 3D system...","color: green; font-weight: bold;");const i=document.getElementById("loading-container");i&&(i.style.opacity="0",i.style.pointerEvents="none",i.style.transition="opacity .3s",setTimeout(()=>{i&&(i.style.display="none")},350)),this.container.style.display="block",console.log("[SimpleMine3DViewer] Container dimensions:",{clientWidth:this.container.clientWidth,clientHeight:this.container.clientHeight,offsetWidth:this.container.offsetWidth,offsetHeight:this.container.offsetHeight}),(this.container.clientWidth===0||this.container.clientHeight===0)&&console.warn("[SimpleMine3DViewer] Container has zero dimensions, using default sizes"),console.log("[SimpleMine3DViewer] Creating scene..."),this.scene=new rt,this.scene.background=new Z(8900331),console.log("[SimpleMine3DViewer] Scene created:",this.scene),console.log("[SimpleMine3DViewer] Creating camera...");const n=this.container.clientWidth/this.container.clientHeight||16/9;this.camera=new lt(60,n,.1,500),this.camera.position.set(15,5,25),this.camera.lookAt(0,-2,0),console.log("[SimpleMine3DViewer] Camera created:",{fov:this.camera.fov,aspect:this.camera.aspect,position:this.camera.position,near:this.camera.near,far:this.camera.far}),console.log("[SimpleMine3DViewer] Creating renderer..."),this.renderer=new Ce({antialias:!0,alpha:!0,powerPreference:"high-performance"});const o=this.container.clientWidth||800,s=this.container.clientHeight||600;if(this.renderer.setSize(o,s),this.renderer.setPixelRatio(Math.min(window.devicePixelRatio,2)),this.renderer.shadowMap.enabled=!1,this.renderer.toneMapping=qe,this.renderer.toneMappingExposure=1.2,this.renderer.outputColorSpace=Ye,this.renderer.domElement.style.width="100%",this.renderer.domElement.style.height="100%",this.renderer.domElement.style.display="block",this.renderer.domElement.style.position="relative",console.log("[SimpleMine3DViewer] Renderer created:",{width:o,height:s,shadowMap:this.renderer.shadowMap.enabled,toneMapping:this.renderer.toneMapping,domElement:this.renderer.domElement}),console.log("[SimpleMine3DViewer] Appending renderer to container..."),this.container.appendChild(this.renderer.domElement),console.log("[SimpleMine3DViewer] Renderer appended successfully"),console.log("[SimpleMine3DViewer] Adding lights..."),this.addLights(),this.options.enableWebGL2)try{console.log("🚀 Initializing WebGL2 Enhanced Renderer..."),this.webgl2Renderer=new vt(this.container,{debug:this.options.debugPerformance,...this.options}),this.webgl2Renderer.isWebGL2Supported?(this.container.removeChild(this.renderer.domElement),this.renderer.dispose(),this.renderer=this.webgl2Renderer.renderer,console.log("✅ WebGL2 Enhanced Renderer activated")):console.log("⚠️ WebGL2 not supported, using standard renderer")}catch(r){console.warn("⚠️ WebGL2 Enhanced Renderer failed to initialize:",r)}if(this.options.enableCollisionDetection)try{console.log("🔍 Initializing Collision Detection System..."),this.collisionSystem=new xt(this.scene,{debug:this.options.debugCollisions,enableSpatialPartitioning:!0,gridSize:10,debugVisualization:this.options.debugCollisions}),console.log("✅ Collision Detection System activated")}catch(r){console.warn("⚠️ Collision Detection System failed to initialize:",r)}if(this.options.enableAdvancedShaders&&this.renderer)try{if(console.log("🎨 Initializing Advanced Shader Manager..."),this.shaderManager=new Mt(this.renderer),(e=this.webgl2Renderer)!=null&&e.isWebGL2Supported){const r=this.webgl2Renderer.createAdvancedLighting(this.scene);console.log("✨ Enhanced WebGL2 lighting activated")}console.log("✅ Advanced Shader Manager activated")}catch(r){console.warn("⚠️ Advanced Shader Manager failed to initialize:",r)}if(this.options.debugPerformance||this.options.enablePerformanceMonitoring)try{console.log("📊 Initializing Performance Monitor..."),this.performanceMonitor=new St({enableGPUTiming:((t=this.webgl2Renderer)==null?void 0:t.isWebGL2Supported)||!1,enableMemoryMonitoring:!0,alertThresholds:{fps:20,memoryMB:300,drawCalls:800}}),this.performanceMonitor.onAlert((r,h)=>{h.forEach(l=>{console.warn(`📊 Performance Alert [${l.type}]:`,l.message),l.severity==="critical"&&this.showError(`Performance issue: ${l.message}`)})}),this.performanceMonitor.startMonitoring(this.renderer),console.log("✅ Performance Monitor activated")}catch(r){console.warn("⚠️ Performance Monitor failed to initialize:",r)}console.log("[SimpleMine3DViewer] Adding test geometry..."),this.addTestGeometry(),console.log("[SimpleMine3DViewer] Setting up controls..."),this.controls=new ct(this.camera,this.renderer.domElement),this.controls.enableDamping=!0,this.controls.dampingFactor=.05,this.controls.enableZoom=!0,this.controls.enablePan=!0,this.controls.enableRotate=!0,this.controls.rotateSpeed=4,this.controls.zoomSpeed=5,this.controls.panSpeed=4.5,this.controls.minDistance=1,this.controls.maxDistance=1e3,this.controls.zoomToCursor=!0,this.controls.maxPolarAngle=Math.PI*.9,this.controls.minPolarAngle=Math.PI*.1,this.controls.maxAzimuthAngle=1/0,this.controls.minAzimuthAngle=-1/0,this.controls.autoRotate=!1,this.controls.autoRotateSpeed=1,this.controls.enableKeys=!0,this.controls.keys={LEFT:"ArrowLeft",UP:"ArrowUp",RIGHT:"ArrowRight",BOTTOM:"ArrowDown"},this.controls.mouseButtons={LEFT:Me.ROTATE,MIDDLE:Me.DOLLY,RIGHT:Me.PAN},this.controls.touches={ONE:Le.ROTATE,TWO:Le.DOLLY_PAN},this.controls.target.set(0,-3,0),this.controls.update(),console.log("[SimpleMine3DViewer] OrbitControls initialized with enhanced settings:",this.controls),console.log("[SimpleMine3DViewer] Initializing path drawer..."),this.pathDrawer=new Et(this.scene,this.camera,this.renderer),this.setupPathDrawingEvents(),this.pathEditor=new Pt(this.scene,this.camera,this.renderer,this.pathDrawer),this.pathEditor.setCallbacks({onPointChange:(r,h)=>{var l,d;if(this.markPathDirty(h.id||h.pathId),this.selectedObject&&(((l=this.selectedObject.userData.objectData)==null?void 0:l.id)===h.id||((d=this.selectedObject.userData.objectData)==null?void 0:d.pathId)===h.id)){const c=this.selectedObject.userData.objectData;c&&(c.points=r,c.path_points=r,c.length=this.pathDrawer.calculatePathLength(r),this.populateSelectionCard(this.selectedObject,c))}}}),console.log("[SimpleMine3DViewer] Initializing object creator..."),this.objectCreator=new Dt(this.scene,this.camera,this.renderer,this),console.log("[SimpleMine3DViewer] Initializing transform controls..."),this.transformControls=new ut(this.camera,this.renderer.domElement),this.transformControls.addEventListener("change",()=>this.renderer.render(this.scene,this.camera)),this.transformControls.addEventListener("dragging-changed",r=>{this.controls.enabled=!r.value}),this.scene.add(this.transformControls),setTimeout(()=>{this.setupMiningControls()},100),console.log("[SimpleMine3DViewer] Initializing object selector..."),this.objectSelector=new zt(this.scene,this.camera,this.renderer),this.setupObjectSelection(),this.ensureUndoRedoUI(),this.renderer.domElement.addEventListener("pointerdown",r=>{this.pathEditor&&this.pathEditor.isEditing&&this.pathEditor.pointerDown(r)}),this.renderer.domElement.addEventListener("pointermove",r=>{this.pathEditor&&this.pathEditor.isEditing&&this.pathEditor.pointerMove(r)}),this.renderer.domElement.addEventListener("pointerup",r=>{this.pathEditor&&this.pathEditor.isEditing&&this.pathEditor.pointerUp(r)}),console.log("[SimpleMine3DViewer] Loading mine data..."),await this.loadMineData(),console.log("[SimpleMine3DViewer] Starting render loop..."),this.animate(),console.log("%c[SimpleMine3DViewer] Initialization completed successfully!","color: green; font-weight: bold; font-size: 14px;");const a=document.getElementById("loading-container");a&&a.style.display!=="none"&&(console.log("[SimpleMine3DViewer] Forcing loading container hide at end"),a.remove())}catch(i){throw console.error("%c[SimpleMine3DViewer] Initialization failed:","color: red; font-weight: bold;",{message:i.message,stack:i.stack,name:i.name}),i}}addLights(){console.log("[SimpleMine3DViewer] Adding shadowless lights to scene...");const e=new Qe(4210752,.6);this.scene.add(e),console.log("[SimpleMine3DViewer] Ambient light added:",e);const t=new Ze(16777215,.9);t.position.set(50,50,50),t.castShadow=!1,this.scene.add(t),console.log("[SimpleMine3DViewer] Directional light added (shadowless):",t);const i=new ht(8900331,9127187,.5);i.position.set(0,20,0),this.scene.add(i),console.log("[SimpleMine3DViewer] Hemisphere light added:",i),[{pos:[10,2,10],color:16768324,intensity:.4},{pos:[-10,2,10],color:16768324,intensity:.4},{pos:[10,2,-10],color:16768324,intensity:.4},{pos:[-10,2,-10],color:16768324,intensity:.4}].forEach((o,s)=>{const a=new Te(o.color,o.intensity,25);a.position.set(...o.pos),a.castShadow=!1,this.scene.add(a)}),console.log("[SimpleMine3DViewer] Mining lights added successfully")}setupMiningControls(){console.log("[SimpleMine3DViewer] Setting up mining controls...");const e=document.querySelectorAll(".mining-tool-btn");console.log("[SimpleMine3DViewer] Found tool buttons:",e.length,e),e.forEach(r=>{const h=r.getAttribute("data-tool");console.log("[SimpleMine3DViewer] Setting up button for tool:",h),r.addEventListener("click",l=>{l.preventDefault(),console.log(`🛠️ Mining tool butonuna tıklandı: ${h}`),this.startMiningTool(h)})});const t=document.getElementById("axis-x-btn"),i=document.getElementById("axis-y-btn"),n=document.getElementById("axis-z-btn"),o=document.getElementById("free-draw-btn");t&&t.addEventListener("click",()=>this.setDrawingConstraint("x")),i&&i.addEventListener("click",()=>this.setDrawingConstraint("y")),n&&n.addEventListener("click",()=>this.setDrawingConstraint("z")),o&&o.addEventListener("click",()=>this.setDrawingConstraint("free"));const s=document.getElementById("reset-camera-btn"),a=document.getElementById("toggle-grid-btn");s&&s.addEventListener("click",()=>{this.camera.position.set(15,5,25),this.camera.lookAt(0,-2,0),this.controls.target.set(0,-3,0),this.controls.update()}),a&&a.addEventListener("click",()=>{const r=this.scene.getObjectByName("grid_helper");r&&(r.visible=!r.visible)}),console.log("[SimpleMine3DViewer] Mining controls setup completed")}startMiningTool(e){console.log("🚀 [SimpleMine3DViewer] Starting mining tool:",e),this.isPathDrawingMode&&(console.log("🛑 Mevcut çizim modu durduruluyor..."),this.stopPathDrawing()),this.isCreatingMode&&(console.log("� Mevcut oluşturma modu durduruluyor..."),this.stopCreating()),console.log("🔧 Object creation mode başlatılıyor:",e),this.isCreatingMode=!0,this.controls.enabled=!1,this.objectCreator.startCreating(e),console.log("� Button states güncelleniyor..."),this.updateToolButtonStates(e),console.log("🎉 Mining tool başlatma işlemi tamamlandı:",e)}stopCreating(){this.isCreatingMode&&(this.isCreatingMode=!1,this.controls.enabled=!0,this.objectCreator.stopCreating(),this.deselectObject(),this.updateToolButtonStates(null),console.log("[SimpleMine3DViewer] Creating mode stopped"))}updateToolIndicator(e){const t=document.getElementById("tool-indicator"),i=document.getElementById("tool-name");if(t&&i){const o={tunnel:{icon:"fas fa-mountain",name:"Tünel Kazma"},road:{icon:"fas fa-road",name:"Yol İnşaası"},rail:{icon:"fas fa-train",name:"Ray Döşeme"},conveyor:{icon:"fas fa-conveyor-belt",name:"Konveyör Kurma"}}[e]||{icon:"fas fa-tools",name:"Bilinmeyen Araç"};t.querySelector("i").className=o.icon+" me-2",i.textContent=o.name,t.style.display="block"}}updateToolButtonStates(e){document.querySelectorAll(".mining-tool-btn").forEach(i=>{const n=i.getAttribute("data-tool");i.classList.remove("btn-warning","btn-info","btn-success","btn-danger","btn-outline-warning","btn-outline-info","btn-outline-success","btn-outline-danger"),n===e?i.classList.add(`btn-${this.getToolColor(n)}`):i.classList.add(`btn-outline-${this.getToolColor(n)}`)}),console.log("[SimpleMine3DViewer] Tool button states updated, active tool:",e)}getToolColor(e){return{tunnel:"warning",road:"info",rail:"success",conveyor:"danger"}[e]||"secondary"}setDrawingConstraint(e){console.log("[SimpleMine3DViewer] Setting drawing constraint to:",e),this.activeConstraint=e,document.querySelectorAll("#axis-x-btn, #axis-y-btn, #axis-z-btn, #free-draw-btn").forEach(n=>{n.classList.remove("btn-light","btn-outline-light"),n.classList.add("btn-outline-light")});let i=null;switch(e){case"x":i=document.getElementById("axis-x-btn");break;case"y":i=document.getElementById("axis-y-btn");break;case"z":i=document.getElementById("axis-z-btn");break;case"free":i=document.getElementById("free-draw-btn");break}i&&(i.classList.remove("btn-outline-light"),i.classList.add("btn-light")),this.pathDrawer&&this.pathDrawer.setAxisConstraint(e),console.log("[SimpleMine3DViewer] Constraint set to:",e)}addTestGeometry(){console.log("[SimpleMine3DViewer] Adding test geometry...");try{console.log("[SimpleMine3DViewer] Creating infinite ground plane...");const e=2e4,t=new Pe(e,e,50,50),i=new ve({color:5668166,transparent:!1}),n=new f(t,i);n.rotation.x=-Math.PI/2,n.position.y=-5,n.receiveShadow=!0,n.name="ground_plane",this.scene.add(n),console.log("[SimpleMine3DViewer] Infinite ground plane added:",n);const o=new dt(e,100,8947848,4473924);o.position.y=-4.9,o.material.opacity=.3,o.material.transparent=!0,this.scene.add(o);const s=new Pe(e,e),a=new ve({color:9127187,transparent:!0,opacity:.8}),r=new f(s,a);r.rotation.x=-Math.PI/2,r.position.y=-10,r.receiveShadow=!0,r.name="underground_layer",this.scene.add(r),console.log("[SimpleMine3DViewer] Test geometry added successfully"),console.log("[SimpleMine3DViewer] Scene children count:",this.scene.children.length),setTimeout(()=>{this.updateAllTunnelEndpoints()},500)}catch(e){throw console.error("[SimpleMine3DViewer] Error adding test geometry:",e),e}}async loadMineData(){console.log("[SimpleMine3DViewer] Loading mine data for mine ID:",this.mineId);try{const e=`/api/mines/${this.mineId}/scene-data`;console.log("[SimpleMine3DViewer] Fetching from URL:",e);const t=await fetch(e);if(console.log("[SimpleMine3DViewer] Fetch response:",{ok:t.ok,status:t.status,statusText:t.statusText,headers:Object.fromEntries(t.headers.entries())}),!t.ok)throw new Error(`HTTP ${t.status}: ${t.statusText}`);const i=await t.json();console.log("[SimpleMine3DViewer] Mine data loaded successfully:",i),i&&i.models&&console.log("[SimpleMine3DViewer] Processing",i.models.length,"models"),i&&i.layers&&console.log("[SimpleMine3DViewer] Processing",i.layers.length,"layers"),i&&i.paths&&(console.log("[SimpleMine3DViewer] Processing",i.paths.length,"paths"),this.loadPaths(i.paths)),setTimeout(()=>{this.updateAllTunnelEndpoints()},1e3)}catch(e){console.warn("[SimpleMine3DViewer] Could not load mine data:",{message:e.message,stack:e.stack}),console.log("[SimpleMine3DViewer] Continuing with test geometry only")}}loadPaths(e){console.log("[SimpleMine3DViewer] Loading paths:",e),e.forEach(t=>{if(t.path_points&&t.path_points.length>1){const i=t.path_points.map(o=>new u(o.x,o.y,o.z)),n=this.pathDrawer.createPath({id:t.id,points:i,width:t.width||3,height:t.height||3,color:t.color||"#808080",type:t.type||"tunnel"});n&&this.objectSelector&&this.objectSelector.addSelectableObject(n,{id:t.id,type:"path",name:t.name,pathType:t.type,width:t.width,height:t.height,color:t.color,material:t.material,points:t.path_points,length:this.pathDrawer.calculatePathLength(t.path_points)})}})}animate(){const e=performance.now(),t=e*.001;requestAnimationFrame(()=>this.animate());try{if(this.controls&&this.controls.update(),this.collisionSystem&&this.collisionSystem.update(),this.shaderManager&&this.shaderManager.updateShaderUniforms(t,this.camera),this.performanceMonitor&&this.performanceMonitor.update(),this.pathDrawer&&this.pathDrawer.updateLOD(),this._measurementGroup&&this.camera){const o=this.camera.quaternion;this._measurementGroup.traverse(s=>{s.isSprite&&s.quaternion.copy(o)})}this.webgl2Renderer?this.webgl2Renderer.render(this.scene,this.camera):this.renderer&&this.scene&&this.camera?this.renderer.render(this.scene,this.camera):console.error("[SimpleMine3DViewer] Missing components for rendering:",{renderer:!!this.renderer,scene:!!this.scene,camera:!!this.camera})}catch(o){console.error("[SimpleMine3DViewer] Render error:",o)}const n=performance.now()-e;this.frameCount||(this.frameCount=0),this.frameCount++,this.frameCount%60===0&&console.log(`[SimpleMine3DViewer] Performance - Frame ${this.frameCount}, Frame time: ${n.toFixed(2)}ms`)}destroy(){this.renderer&&(this.container.removeChild(this.renderer.domElement),this.renderer.dispose())}setupPathDrawingEvents(){const e=this.renderer.domElement;this.boundHandlers={click:t=>this.handleCanvasClick(t),mousemove:t=>this.handleCanvasMouseMove(t),keydown:t=>this.handleKeyDown(t)},e.addEventListener("click",this.boundHandlers.click),e.addEventListener("mousemove",this.boundHandlers.mousemove),document.addEventListener("keydown",this.boundHandlers.keydown)}handleCanvasClick(e){e.preventDefault(),e.stopPropagation(),this.isPathDrawingMode?this.pathDrawer.handleClick(e):this.isCreatingMode?this.updateCreationPosition(e):(this.objectSelector?this.objectSelector.handleClick(e):this.handleObjectSelection(e),!this.selectedObject&&this.objectCreator&&this.objectCreator.previewObject&&this.objectCreator.removePreview())}updateCreationPosition(e){const t=this.renderer.domElement.getBoundingClientRect(),i=new re;i.x=(e.clientX-t.left)/t.width*2-1,i.y=-((e.clientY-t.top)/t.height)*2+1;const n=new ie;n.setFromCamera(i,this.camera);const o=new Ie(new u(0,1,0),-2),s=new u;n.ray.intersectPlane(o,s)&&(this.objectCreator.currentPosition.copy(s),this.objectCreator.createPreview(),console.log("[SimpleMine3DViewer] Updated creation position:",s))}handleObjectSelection(e){const t=this.renderer.domElement.getBoundingClientRect(),i=new re;i.x=(e.clientX-t.left)/t.width*2-1,i.y=-((e.clientY-t.top)/t.height)*2+1;const n=new ie;n.setFromCamera(i,this.camera);const o=[];this.scene.traverse(a=>{a.userData&&a.userData.selectable&&a.isMesh&&o.push(a)});const s=n.intersectObjects(o);if(s.length>0){const a=s[0].object;this.selectObject(a)}else this.deselectObject()}selectObject(e){this.selectedObject&&this.deselectObject(),this.selectedObject=e,this.transformControls.attach(e),this.addHighlight(e)}deselectObject(){this.selectedObject&&(this.transformControls.detach(),this.removeHighlight(this.selectedObject),this.selectedObject=null,console.log("[SimpleMine3DViewer] Object deselected")),this.objectCreator&&this.objectCreator.removePreview()}addHighlight(e){e.userData.originalMaterial||(e.userData.originalMaterial=e.material,e.material=e.material.clone(),e.material.emissive.setHex(4473924))}removeHighlight(e){e.userData.originalMaterial&&(e.material.dispose(),e.material=e.userData.originalMaterial,delete e.userData.originalMaterial)}markPathDirty(e){e&&(clearTimeout(this._pathSaveTimer),this.setPathDirtyVisual(!0),this._dirtyPaths.add(e),this._pathSaveTimer=setTimeout(async()=>{const t=this.pathDrawer.getPath(e);if(!t)return;const i=t.userData.pathData||{};try{await this.updatePathToServer(e,{points:i.points||i.path_points}),this._dirtyPaths.delete(e),this._dirtyPaths.size===0&&this.setPathDirtyVisual(!1)}catch{}},600))}setPathDirtyVisual(e){this._dirtyIndicatorEl||(this._dirtyIndicatorEl=document.getElementById("save-path-btn")),this._dirtyIndicatorEl&&(e?this._dirtyIndicatorEl.classList.add("dirty"):this._dirtyIndicatorEl.classList.remove("dirty"))}handleCanvasMouseMove(e){this.isPathDrawingMode&&this.pathDrawer.handleMouseMove(e)}handleKeyDown(e){console.log("[SimpleMine3DViewer] Key pressed:",e.key),e.key==="Escape"?(e.preventDefault(),this.isPathDrawingMode?(this.pathDrawer.stopDrawing(),this.stopPathDrawing()):this.isCreatingMode?this.stopCreating():this.selectedObject&&this.deselectObject()):e.key==="Enter"&&this.isPathDrawingMode?(e.preventDefault(),this.completeCurrentPath()):e.key==="Delete"||e.key==="Backspace"?(e.preventDefault(),this.selectedObject?this.deleteSelectedObject():console.log("[SimpleMine3DViewer] No object selected for deletion")):e.key==="g"||e.key==="G"?(e.preventDefault(),this.selectedObject&&this.transformControls.object&&this.cycleTransformMode()):(e.metaKey||e.ctrlKey)&&(e.key==="z"||e.key==="Z")?(e.preventDefault(),this.pathEditor&&this.pathEditor.isEditing&&this.pathEditor.undo()):(e.metaKey||e.ctrlKey)&&e.shiftKey&&(e.key==="z"||e.key==="Z")?(e.preventDefault(),this.pathEditor&&this.pathEditor.isEditing&&this.pathEditor.redo()):e.key==="m"||e.key==="M"?(e.preventDefault(),this.toggleMeasurements()):(e.key==="e"||e.key==="E")&&(e.preventDefault(),this.updateAllTunnelEndpoints(),console.log("[SimpleMine3DViewer] Endpoint update triggered by E key"))}toggleMeasurements(e=null){const t=e===null?!this.measurementsEnabled:!!e;if(t!==this.measurementsEnabled){if(this.measurementsEnabled=t,!t)this._measurementGroup&&(this._measurementGroup.traverse(i=>{i.geometry&&i.geometry.dispose(),i.material&&i.material.dispose()}),this.scene.remove(this._measurementGroup),this._measurementGroup=null);else if(this._lastMeasuredTunnel){const{object:i,data:n}=this._lastMeasuredTunnel;this.buildTunnelMeasurements(i,n)}console.log("[SimpleMine3DViewer] Measurements toggled ->",this.measurementsEnabled)}}cycleTransformMode(){const e=this.transformControls.getMode(),t=["translate","rotate","scale"],i=t.indexOf(e),n=t[(i+1)%t.length];this.transformControls.setMode(n),console.log("[SimpleMine3DViewer] Transform mode changed to:",n)}async saveObjectToServer(e){var t,i;try{const n={mine_id:this.mineId,name:`${e.userData.type.charAt(0).toUpperCase()+e.userData.type.slice(1)} ${e.userData.id}`,type:e.userData.type,geometry:{type:e.userData.type,...e.userData.parameters},material:{color:e.material.color.getHex(),opacity:e.material.opacity||1},position:[e.position.x,e.position.y,e.position.z],rotation:[e.rotation.x,e.rotation.y,e.rotation.z],scale:[e.scale.x,e.scale.y,e.scale.z],properties:{createdAt:new Date().toISOString(),tool:e.userData.type},visible:!0,order:e.userData.id},o=await fetch(`/api/mines/${this.mineId}/models`,{method:"POST",headers:{"Content-Type":"application/json","X-CSRF-TOKEN":((t=document.querySelector('meta[name="csrf-token"]'))==null?void 0:t.getAttribute("content"))||"",Accept:"application/json"},body:JSON.stringify(n)});if(o.ok){const s=await o.json();e.userData.serverId=(i=s.data)==null?void 0:i.id,console.log("[SimpleMine3DViewer] Successfully saved object to server:",s),this.showSuccess("Obje başarıyla kaydedildi!"),this.deselectObject(),this.forceExitCreationMode(),console.log("[SimpleMine3DViewer] Obje kaydedildi ve düzenleme modu kapatıldı")}else throw new Error(`HTTP ${o.status}: ${o.statusText}`)}catch(n){console.error("[SimpleMine3DViewer] Error saving object to server:",n),this.showError("Obje kaydedilemedi: "+n.message)}}forceExitCreationMode(){var t,i;if(this.objectCreator){this.objectCreator.isCreating=!1;try{(i=(t=this.objectCreator).hideCreationUI)==null||i.call(t)}catch{}try{this.objectCreator.removePreview()}catch{}}this.isCreatingMode=!1,this.isPathDrawingMode=!1,this.transformControls&&this.transformControls.detach(),this.selectedObject&&(this.removeHighlight(this.selectedObject),this.selectedObject=null),this.controls&&(this.controls.enabled=!0);const e=document.getElementById("creation-panel");e&&(e.style.display="none"),this.showPathDrawingUI(!1),this.updateToolButtonStates(null),console.log("[SimpleMine3DViewer] Force exited all creation/editing modes")}showSuccess(e){const t=document.createElement("div");t.style.cssText=`
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: #44aa44;
            color: white;
            padding: 10px 20px;
            border-radius: 5px;
            z-index: 10000;
        `,t.textContent=e,document.body.appendChild(t),setTimeout(()=>{t.parentNode&&document.body.removeChild(t)},3e3)}showError(e){const t=document.createElement("div");t.style.cssText=`
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: #ff4444;
            color: white;
            padding: 10px 20px;
            border-radius: 5px;
            z-index: 10000;
        `,t.textContent=e,document.body.appendChild(t),setTimeout(()=>{t.parentNode&&document.body.removeChild(t)},3e3)}deleteSelectedObject(){if(this.selectedObject){const e=this.selectedObject;this.transformControls.detach(),this.scene.remove(e),e.geometry&&e.geometry.dispose(),e.material&&e.material.dispose(),this.objectCreator.createdObjects.has(e.userData.id)&&this.objectCreator.createdObjects.delete(e.userData.id),this.selectedObject=null,console.log("[SimpleMine3DViewer] Object deleted:",e.userData),e.userData.serverId&&this.deleteFromServer(e.userData.serverId)}}async deleteFromServer(e){var t;try{const i=await fetch(`/api/mines/${this.mineId}/models/${e}`,{method:"DELETE",headers:{"X-CSRF-TOKEN":((t=document.querySelector('meta[name="csrf-token"]'))==null?void 0:t.getAttribute("content"))||"",Accept:"application/json"}});if(i.ok)console.log("[SimpleMine3DViewer] Successfully deleted from server"),this.showSuccess("Obje başarıyla silindi!");else throw new Error(`HTTP ${i.status}: ${i.statusText}`)}catch(i){console.error("[SimpleMine3DViewer] Error deleting from server:",i),this.showError("Obje silinemedi: "+i.message)}}setupObjectSelection(){this.objectSelector.setCallbacks({onObjectSelect:(e,t)=>this.onObjectSelected(e,t),onObjectDeselect:e=>this.onObjectDeselected(e),onObjectDelete:e=>this.onObjectDelete(e)})}onObjectSelected(e,t){const i=t||e&&e.userData&&e.userData.objectData||e.userData||{};if(console.log("[SimpleMine3DViewer] Object selected:",i),this.selectedObject=e,this.showSelectionCard(e,i),i&&(i.pathType||i.type==="path")&&this.pathEditor){const n=e.parent&&e.parent.userData&&e.parent.userData.pathData?e.parent:e;this.pathEditor.startEditing(n)}i&&i.type==="tunnel"&&this.buildTunnelMeasurements(e,i)}onObjectDeselected(e){console.log("[SimpleMine3DViewer] Object deselected"),this._measurementGroup&&(this._measurementGroup.traverse(t=>{t.geometry&&t.geometry.dispose(),t.material&&t.material.dispose()}),this.scene.remove(this._measurementGroup),this._measurementGroup=null),this.selectedObject=null,this.hideSelectionCard(),this.pathEditor&&this.pathEditor.isEditing&&this.pathEditor.stopEditing()}async onObjectDelete(e){var i;console.log("[SimpleMine3DViewer] Deleting object:",e.userData.objectData);const t=e.userData.objectData;if(t&&t.id&&t.type==="path")try{const n=await fetch(`/api/mines/${this.mineId}/paths/${t.id}`,{method:"DELETE",headers:{"X-CSRF-TOKEN":((i=document.querySelector('meta[name="csrf-token"]'))==null?void 0:i.getAttribute("content"))||"",Accept:"application/json"}});if(n.ok)this.pathDrawer.removePath(t.id),this.objectSelector.removeSelectableObject(e),console.log("[SimpleMine3DViewer] Path deleted successfully");else throw new Error(`HTTP ${n.status}: ${n.statusText}`)}catch(n){console.error("[SimpleMine3DViewer] Error deleting path:",n),this.showError("Yol silinemedi: "+n.message)}}startPathDrawing(){this.isPathDrawingMode=!0,this.controls.enabled=!1,this.pathDrawer.startDrawing({onPathStart:()=>console.log("[SimpleMine3DViewer] Yol çizimi başladı"),onPathUpdate:e=>console.log("[SimpleMine3DViewer] Yol güncellendi, nokta sayısı:",e.length),onPathComplete:e=>this.onPathDrawingComplete(e)}),this.showPathDrawingUI(!0),console.log("[SimpleMine3DViewer] Yol çizim modu aktif")}stopPathDrawing(){this.isPathDrawingMode=!1,this.controls.enabled=!0,this.pathDrawer.stopDrawing(),this.showPathDrawingUI(!1),console.log("[SimpleMine3DViewer] Yol çizim modu pasif")}completeCurrentPath(){if(this.isPathDrawingMode){console.log("[SimpleMine3DViewer] Manual path completion");const e=this.pathDrawer.completePath();e&&e.length>1&&(this.onPathDrawingComplete(e),this.stopPathDrawing())}}onPathDrawingComplete(e){console.log("[SimpleMine3DViewer] Yol çizimi tamamlandı:",e),this.savePathToServer(e).then(t=>{if(t){const i=this.pathDrawer.createPath({id:t.id,points:e,width:t.width||2.5,height:t.height||2.5,color:t.color||"#808080",type:t.type||"tunnel"});i&&this.objectSelector&&this.objectSelector.addSelectableObject(i,{id:t.id,type:"path",name:t.name,pathType:t.type,width:t.width,height:t.height,color:t.color,material:t.material,points:e.map(n=>({x:n.x,y:n.y,z:n.z})),length:this.pathDrawer.calculatePathLength(e.map(n=>({x:n.x,y:n.y,z:n.z})))}),this.deselectObject(),this.forceExitCreationMode(),console.log("[SimpleMine3DViewer] Yol kaydedildi ve düzenleme modu kapatıldı")}}).catch(t=>{console.error("[SimpleMine3DViewer] Yol kaydetme hatası:",t),this.showError("Yol kaydedilemedi: "+t.message)})}async savePathToServer(e){var t;try{const i={mine_id:this.mineId,name:`Yol ${Date.now()}`,type:"tunnel",path_points:e.map(a=>({x:a.x,y:a.y,z:a.z})),width:2.5,height:2.5,color:"#808080",status:"active"},n=await fetch(`/api/mines/${this.mineId}/paths`,{method:"POST",headers:{"Content-Type":"application/json","X-CSRF-TOKEN":((t=document.querySelector('meta[name="csrf-token"]'))==null?void 0:t.getAttribute("content"))||"",Accept:"application/json"},body:JSON.stringify(i)});if(!n.ok){const a=await n.json().catch(()=>({}));throw new Error(a.message||`HTTP ${n.status}: ${n.statusText}`)}const o=await n.json(),s=o.data||o;return console.log("[SimpleMine3DViewer] Yol başarıyla kaydedildi:",s),s}catch(i){throw console.error("[SimpleMine3DViewer] Yol kaydetme hatası:",i),i}}async updatePathToServer(e,t){var i;try{const n={...t};n.points&&!n.path_points&&(n.path_points=n.points.map(r=>({x:r.x,y:r.y,z:r.z})),delete n.points);const o=await fetch(`/api/mines/${this.mineId}/paths/${e}`,{method:"PUT",headers:{"Content-Type":"application/json","X-CSRF-TOKEN":((i=document.querySelector('meta[name="csrf-token"]'))==null?void 0:i.getAttribute("content"))||"",Accept:"application/json"},body:JSON.stringify(n)});if(!o.ok){const r=await o.json().catch(()=>({}));throw new Error(r.message||`HTTP ${o.status}: ${o.statusText}`)}const s=await o.json();console.log("[SimpleMine3DViewer] Yol güncellendi:",s.data||s),this.showSuccess("Yol güncellendi");const a=document.getElementById("save-path-btn");return a&&(a.classList.add("saved-once"),setTimeout(()=>a.classList.remove("saved-once"),400)),s.data||s}catch(n){throw console.error("[SimpleMine3DViewer] Yol güncelleme hatası:",n),this.showError("Yol güncellenemedi: "+n.message),n}}dispose(){if(console.log("[SimpleMine3DViewer] Disposing viewer"),window.removeEventListener("resize",this._resizeHandler),document.removeEventListener("keydown",this._keyHandler),this.renderer&&this.renderer.domElement){const e=this.renderer.domElement;e.removeEventListener("click",this._clickHandler),e.removeEventListener("mousemove",this._mouseMoveHandler)}this.scene&&this.scene.traverse(e=>{e.isMesh&&(e.geometry&&e.geometry.dispose(),e.material&&(Array.isArray(e.material)?e.material.forEach(t=>t.dispose()):e.material.dispose()))}),this.renderer&&this.renderer.dispose(),this.scene=null,this.camera=null,this.renderer=null}buildTunnelMeasurements(e,t){if(!this.measurementsEnabled||!e||!e.geometry)return;this._measurementGroup&&(this._measurementGroup.traverse(g=>{g.geometry&&g.geometry.dispose(),g.material&&g.material.dispose()}),this.scene.remove(this._measurementGroup));const i=new we;i.name="tunnel_measurements",this._measurementGroup=i,this.scene.add(i),this._lastMeasuredTunnel={object:e,data:t};const n=t.parameters||{};n.orientation==="yatay"&&(n.orientation="horizontal"),n.orientation==="dikey"&&(n.orientation="vertical");let o=n.width||3,s=n.height||3,a=n.length||10,r=n.orientation||"horizontal";try{e.geometry.computeBoundingBox();const g=e.geometry.boundingBox,b=new u;g.getSize(b),r==="vertical"?(a=b.y,o=b.x,s=b.z):(a=b.z,o=b.x,s=b.y)}catch{}const h=r==="vertical"?"y":"z",l=e.position.clone(),d=new J({color:43775,transparent:!0,opacity:.85,depthTest:!1,depthWrite:!1}),c=new J({color:30668,transparent:!0,opacity:.45,depthTest:!1,depthWrite:!1}),p="#00aaff",m=(g,b,x)=>{const v=new ae().setFromPoints([g,b]);return new N(v,x)},y=Math.max(1,this.measurementStep||5);{const x=(0/a-.5)*a;let v;if(h==="z"){const E=l.y+s/2+.02;v=new u(l.x+o/2+.2,E,l.z+x)}else{const E=l.z-s/2-.02;v=new u(l.x+o/2+.2,l.y+x,E)}this._addSpriteLabel("0m",v,p,i)}for(let g=y;g<a+.001;g+=y){const x=(g/a-.5)*a;let v,E;if(h==="z"){const C=l.y+s/2+.02;v=new u(l.x-o/2,C,l.z+x),E=new u(l.x+o/2,C,l.z+x)}else{const C=l.z-s/2-.02;v=new u(l.x-o/2,l.y+x,C),E=new u(l.x+o/2,l.y+x,C)}const z=m(v,E,d);i.add(z),this._addSpriteLabel(`${g}m`,E.clone().add(new u(.2,.2,0)),p,i)}const D=.5,S=.5,w=0;for(let g=-o/2;g<=o/2+.001;g+=D){let b,x;if(h==="z"){const v=l.z+w;b=new u(l.x+g,l.y-s/2+.01,v),x=new u(l.x+g,l.y+s/2+.01,v)}else{const v=l.z-s/2;b=new u(l.x+g,l.y+w,v+.01),x=new u(l.x+g,l.y+w,l.z+s/2+.01)}i.add(m(b,x,c))}for(let g=-s/2;g<=s/2+.001;g+=S){let b,x;if(h==="z"){const v=l.z+w;b=new u(l.x-o/2,l.y+g,v+.01),x=new u(l.x+o/2,l.y+g,v+.01)}else{const v=l.z-s/2-.01;b=new u(l.x-o/2,l.y+w,v+g),x=new u(l.x+o/2,l.y+w,v+g)}i.add(m(b,x,c))}try{const g=h==="z"?"Z Ekseni":"Y Ekseni",b=h==="z"?new u(l.x+o/2+.6,l.y+s/2+.4,l.z):new u(l.x+o/2+.6,l.y,l.z-s/2-.6);this._addSpriteLabel(g,b,"#ffaa00",i)}catch{}}replaceTunnelGeometry(e,t){if(!this.objectCreator)return;t.orientation==="yatay"&&(t.orientation="horizontal"),t.orientation==="dikey"&&(t.orientation="vertical");const i=this.objectCreator.createGeometry("tunnel",t);e.geometry&&e.geometry.dispose(),e.geometry=i,e.userData.parameters={...t},this.measurementsEnabled&&this.buildTunnelMeasurements(e,{type:"tunnel",parameters:t})}_addSpriteLabel(e,t,i,n){const o=document.createElement("canvas"),s=256;o.width=s,o.height=s;const a=o.getContext("2d");a.fillStyle="rgba(0,0,0,0.0)",a.fillRect(0,0,s,s),a.fillStyle=i||"#ffffff",a.font="48px Arial",a.textAlign="center",a.textBaseline="middle",a.fillText(e,s/2,s/2);const r=new je(o);r.needsUpdate=!0;const h=new Ae({map:r,transparent:!0}),l=new Ge(h);l.scale.set(1.5,1.5,1.5),l.position.copy(t),n.add(l)}showPathDrawingUI(e){console.log("[SimpleMine3DViewer] Path drawing UI:",e?"show":"hide");const t=document.getElementById("path-controls"),i=document.getElementById("draw-path-btn"),n=document.getElementById("path-btn-text");e?(t&&(t.style.display="block"),n&&(n.textContent="Çizimi Bitir"),i&&(i.classList.remove("btn-outline-warning"),i.classList.add("btn-warning"))):(t&&(t.style.display="none"),n&&(n.textContent="Yol Çiz"),i&&(i.classList.remove("btn-warning"),i.classList.add("btn-outline-warning")));const o=document.getElementById("path-drawing-overlay");if(e&&!o){const s=document.createElement("div");s.id="path-drawing-overlay",s.innerHTML=`
                <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); 
                           background: rgba(0,0,0,0.8); color: white; padding: 20px; border-radius: 10px;
                           text-align: center; z-index: 1000;">
                    <h5>Yol Çizim Modu</h5>
                    <p>Yol noktalarını tıklayarak belirleyin</p>
                    <small>Enter: Tamamla | Escape: İptal</small>
                </div>
            `,this.container.appendChild(s)}else!e&&o&&o.remove()}showError(e){const t=document.getElementById("error-content");t?(t.textContent=e,new bootstrap.Modal(document.getElementById("errorModal")).show()):console.error(e)}getTypeDisplayName(e){return{tunnel:"Tünel",road:"Yol",rail:"Ray",conveyor:"Konveyör"}[e]||e}editSelectedObject(){if(this.selectedObject){const e=this.selectedObject.userData.objectData;console.log("[SimpleMine3DViewer] Editing object:",e),console.info("Düzenleme özelliği yakında gelecek!")}}deleteSelectedObject(){this.selectedObject&&confirm("Bu objeyi silmek istediğinizden emin misiniz?")&&this.objectSelector.deleteSelectedObject()}setCameraPreset(e){switch(e){case"overview":this.camera.position.set(25,15,35),this.controls.target.set(0,-2,0);break;case"side":this.camera.position.set(40,0,0),this.controls.target.set(0,-3,0);break;case"top":this.camera.position.set(0,30,0),this.controls.target.set(0,-3,0);break;case"underground":this.camera.position.set(10,-40,25),this.controls.target.set(0,-45,0);break;case"close":this.camera.position.set(8,2,12),this.controls.target.set(0,-1,0);break;default:this.camera.position.set(15,5,25),this.controls.target.set(0,-3,0)}this.controls.update()}setupTunnelMergeEvents(e,t){const i=document.getElementById("start-tunnel-merge"),n=document.getElementById("tunnel-merge-ui");document.getElementById("target-tunnel-select");const o=document.getElementById("execute-tunnel-merge"),s=document.getElementById("cancel-tunnel-merge");i&&(i.addEventListener("click",()=>{this.populateTargetTunnels(e,t),i.style.display="none",n.style.display="block"}),o&&o.addEventListener("click",()=>{this.executeTunnelMerge(e,t)}),s&&s.addEventListener("click",()=>{this.cancelTunnelMerge()}))}populateTargetTunnels(e,t){const i=document.getElementById("target-tunnel-select");if(!i)return;i.innerHTML='<option value="">Tünel seçin...</option>';const n=[];if(this.scene.traverse(o=>{o.userData&&o.userData.selectable&&o.userData.type==="tunnel"&&o!==e&&n.push({object:o,data:o.userData})}),this.pathDrawer&&this.pathDrawer.paths)for(const[o,s]of this.pathDrawer.paths){const a=s.userData.pathData;a&&a.type==="tunnel"&&s!==e&&n.push({object:s,data:a,isPath:!0})}n.forEach((o,s)=>{const a=o.data.name||`Tünel ${o.data.id||s+1}`,r=document.createElement("option");r.value=o.isPath?`path_${o.data.id}`:`tunnel_${o.data.id}`,r.textContent=a,r.dataset.tunnelType=o.isPath?"path":"tunnel",i.appendChild(r)}),console.log(`[TunnelMerge] Found ${n.length} target tunnels`)}executeTunnelMerge(e,t){var a,r,h;const i=(a=document.getElementById("current-tunnel-endpoint"))==null?void 0:a.value,n=(r=document.getElementById("target-tunnel-select"))==null?void 0:r.value,o=(h=document.getElementById("target-tunnel-endpoint"))==null?void 0:h.value;if(!i||!n||!o){this.showError("Lütfen tüm alanları doldurun!");return}const s=this.findTunnelById(n);if(!s){this.showError("Hedef tünel bulunamadı!");return}console.log("[TunnelMerge] Merging tunnels:",{current:{tunnel:e,endpoint:i,meta:t},target:{tunnel:s.object,endpoint:o,data:s.data}}),this.performTunnelMerge({tunnel:e,endpoint:i,meta:t},{tunnel:s.object,endpoint:o,data:s.data})}findTunnelById(e){const[t,i]=e.split("_");if(t==="path"&&this.pathDrawer&&this.pathDrawer.paths){const n=this.pathDrawer.paths.get(parseInt(i));if(n)return{object:n,data:n.userData.pathData,isPath:!0}}else if(t==="tunnel"){let n=null;return this.scene.traverse(o=>{o.userData&&o.userData.selectable&&o.userData.type==="tunnel"&&o.userData.id==i&&(n={object:o,data:o.userData,isPath:!1})}),n}return null}performTunnelMerge(e,t){try{console.log("[TunnelMerge] Starting merge operation:",{source:e,target:t});const i=this.calculateTunnelEndpoint(e.tunnel,e.endpoint,e.meta),n=this.calculateTunnelEndpoint(t.tunnel,t.endpoint,t.data);if(console.log("[TunnelMerge] Calculated endpoints:",{sourceEndpoint:i,targetEndpoint:n}),!i||!n){this.showError("Tünel uç noktaları hesaplanamadı!"),console.error("[TunnelMerge] Failed to calculate endpoints");return}const o=i.position.distanceTo(n.position);console.log("[TunnelMerge] Distance between endpoints:",o),this.visualizeMergeConnection(i,n),o<2?(console.log("[TunnelMerge] Endpoints are very close, creating simple connection"),this.createDirectConnection(i,n,e,t)):this.createTunnelConnection(i,n,e,t),this.showSuccess(`Tüneller başarıyla birleştirildi! (Mesafe: ${o.toFixed(2)}m)`),setTimeout(()=>{this.cancelTunnelMerge()},3e3)}catch(i){console.error("[TunnelMerge] Merge failed:",i),this.showError("Birleştirme işlemi başarısız: "+i.message)}}createDirectConnection(e,t,i,n){var a,r;if(((a=this.options)==null?void 0:a.mergeStrategy)==="extend-and-fuse"||((r=this.options)==null?void 0:r.mergeStrategy)===void 0){console.log("[TunnelMerge] Skipping direct path because extend-and-fuse mode active"),this.createTunnelConnection(e,t,i,n);return}const s=[e.position.clone(),t.position.clone()];this.createConnectionPath(s,i,n,"direct")}calculateTunnelEndpoint(e,t,i){let n,o;if(console.log("[TunnelEndpoint] Calculating for:",{endpoint:t,metadata:i,tunnel:e}),i.type==="path"||i.pathType==="tunnel"){const a=i.points||i.path_points||[];if(console.log("[TunnelEndpoint] Path points:",a),a.length<2)return console.warn("[TunnelEndpoint] Not enough points for path tunnel"),null;if(t==="A")n=new u(a[0].x,a[0].y,a[0].z),a.length>1?o=new u(a[1].x-a[0].x,a[1].y-a[0].y,a[1].z-a[0].z).normalize():o=new u(1,0,0);else{const r=a.length-1;n=new u(a[r].x,a[r].y,a[r].z),r>0?o=new u(a[r].x-a[r-1].x,a[r].y-a[r-1].y,a[r].z-a[r-1].z).normalize():o=new u(1,0,0)}if(o.lengthSq()<1e-6&&a.length>=3)if(t==="A"){const r=a[0];a[1];const h=a[2];o=new u(h.x-r.x,h.y-r.y,h.z-r.z).normalize()}else{const r=a.length,h=a[r-3],l=a[r-1];o=new u(l.x-h.x,l.y-h.y,l.z-h.z).normalize()}Math.abs(o.y)<.001&&(o.y=0),o.normalize()}else{const a=i.parameters||i,r=a.length||10,h=(a.orientation||"horizontal").toLowerCase(),l=new ze;l.setFromObject(e);const d=new u;l.getSize(d);let c=0;d.y>=d.x&&d.y>=d.z?c=1:d.z>=d.x&&d.z>=d.y&&(c=2);const p=e.rotation?e.rotation.clone():new Xe,m=new u(1,0,0).applyEuler(p).normalize(),y=new u(0,1,0).applyEuler(p).normalize(),D=new u(0,0,1).applyEuler(p).normalize(),S=[m,y,D];let w=S[c];h==="horizontal"&&c===0&&Math.abs(d.z-r)<Math.abs(d.x-r)&&(w=D),h==="horizontal"&&c===1&&(d.z>d.x?w=D:w=m),h==="vertical"&&(w=y);const g=[d.x,d.y,d.z][S.indexOf(w)]||r,b=g/2,x=new u;l.getCenter(x),t==="A"?(n=x.clone().add(w.clone().multiplyScalar(-b)),o=w.clone()):(n=x.clone().add(w.clone().multiplyScalar(b)),o=w.clone()),console.log("[TunnelEndpoint] Improved parametric endpoint:",{orientation:h,realLength:g,chosenAxis:w.toArray(),position:n.toArray()})}const s={position:n,direction:o,tunnel:e,metadata:i};return console.log("[TunnelEndpoint] Final calculated result:",s),s}visualizeMergeConnection(e,t){this.clearMergeVisualization();const i=this.generateCurvedConnection(e,t),n=new ae().setFromPoints(i),o=new J({color:65280,linewidth:4,transparent:!0,opacity:.8});this.mergeConnectionLine=new N(n,o),this.scene.add(this.mergeConnectionLine);const s=new oe(.8,16,16),a=new W({color:16711680,transparent:!0,opacity:.9}),r=new W({color:255,transparent:!0,opacity:.9});this.mergeEndpoint1=new f(s,a),this.mergeEndpoint1.position.copy(e.position),this.scene.add(this.mergeEndpoint1),this.mergeEndpoint2=new f(s,r),this.mergeEndpoint2.position.copy(t.position),this.scene.add(this.mergeEndpoint2),this.animateEndpoints(),console.log("[TunnelMerge] Visualized curved connection with",i.length,"points")}createTunnelConnection(e,t,i,n){var r,h,l,d;const o=e.position.distanceTo(t.position);console.log("[TunnelConnection] Creating connection with distance:",o);const s=((r=this.options)==null?void 0:r.mergeStrategy)||"extend-gap-fill";if(console.log("[TunnelConnection] Strategy:",s),s==="extend-gap-fill")try{this.extendAndFillGap(e,t,i,n),this.clearMergeVisualization(),(h=this.updateAllTunnelEndpoints)==null||h.call(this),this.showSuccess("Tüneller uzatılarak boşluk dolduruldu"),this.persistMergeRecord("extend-gap-fill",e,t,i,n);return}catch(c){console.error("[TunnelConnection] extend-gap-fill failed, fallback curved:",c)}else if(s==="segment-blend")try{this.createSegmentBlend(e,t,i,n),this.clearMergeVisualization(),(l=this.updateAllTunnelEndpoints)==null||l.call(this),this.showSuccess("Parametrik blend segmentleri oluşturuldu"),this.persistMergeRecord("segment-blend",e,t,i,n);return}catch(c){console.error("[TunnelConnection] segment-blend failed, fallback curved:",c)}else if(s==="extend-and-fuse"||s==="fuse-single")try{this.fuseTunnels(e,t,i,n),this.clearMergeVisualization(),(d=this.updateAllTunnelEndpoints)==null||d.call(this),this.showSuccess("Tüneller tek bir tünelde birleştirildi"),this.persistMergeRecord("fuse",e,t,i,n);return}catch(c){console.error("[TunnelConnection] Fuse failed, fallback curved path:",c)}else console.log("[TunnelConnection] Using curved path strategy (no extend)");const a=this.generateCurvedConnection(e,t);this.createConnectionPath(a,i,n,"curved")}extendTunnelToPoint(e,t,i,n,o){if(!e||!t||!i)return;const s=t.parameters?{...t.parameters}:{...t};let a=i.direction?i.direction.clone():null;if(!a||a.lengthSq()===0?a=n.clone().sub(i.position).normalize():a.normalize(),a.lengthSq()===0)return;const r=s.length||t.length||10,h=i.position.distanceTo(n);if(h<.001)return;const l=r+h,d=a.clone().multiplyScalar(h/2*(o==="B"?1:-1));s.length=l;const c=(s.height||s.width||3)/2;if(typeof this.replaceTunnelGeometry=="function")this.replaceTunnelGeometry(e,s,{direction:a});else{e.geometry&&e.geometry.dispose();const y=new B(c,c,l,16,1,!1);y.rotateX(Math.PI/2),e.geometry=y}const p=new u(0,0,1),m=new V().setFromUnitVectors(p,a.clone().normalize());e.setRotationFromQuaternion(m),e.position.add(d),e.userData.parameters={...s},e.userData.objectData&&(e.userData.objectData.parameters={...s})}extendAndFillGap(e,t,i,n){var C,O,A,q;if(!(i!=null&&i.tunnel)||!(n!=null&&n.tunnel))throw new Error("Missing tunnels");const o=i.tunnel,s=n.tunnel,a=i.meta,r=n.data,h=e.position.clone(),l=t.position.clone(),d=l.clone().sub(h),c=d.length();if(c<.01)return;const p=h.clone().add(l).multiplyScalar(.5),m=d.clone().normalize(),y=c/2,D=[o,s].map(R=>this.serializeTunnel(R)),S=D.map(R=>{var P,T,G;return{id:R.id,connected:(((G=(T=(P=this.findSelectableById(R.id))==null?void 0:P.userData)==null?void 0:T.objectData)==null?void 0:G.connectedTunnels)||[]).slice()}});this.extendTunnelHalfGapPrecise(o,a,e.endpoint,m,y),this.extendTunnelHalfGapPrecise(s,r,t.endpoint,m.clone().negate(),y);const w=this.calculateTunnelEndpoint(o,e.endpoint,a).position,g=this.calculateTunnelEndpoint(s,t.endpoint,r).position,b=p.clone().sub(w),x=p.clone().sub(g);b.length()<.2&&o.position.add(b.multiplyScalar(.5)),x.length()<.2&&s.position.add(x.multiplyScalar(.5));const v=Math.min(c*.15,1);let E=null;if(v>.02){const R=((a.width||((C=a.parameters)==null?void 0:C.width)||3)+(r.width||((O=r.parameters)==null?void 0:O.width)||3))/2,P=((a.height||((A=a.parameters)==null?void 0:A.height)||3)+(r.height||((q=r.parameters)==null?void 0:q.height)||3))/2,T=Math.max(R,P)/2*1.03,G=new B(T,T,v,24,1,!1);G.rotateX(Math.PI/2);const L=new X({color:3355443,transparent:!0,opacity:.9});E=new f(G,L);const F=new u(0,0,1),k=new V().setFromUnitVectors(F,m);E.setRotationFromQuaternion(k),E.position.copy(p),E.userData={selectable:!1,helper:!0,type:"merge-sleeve"},this.scene.add(E)}this.addConnectionMeta(o,a,r),this.addConnectionMeta(s,r,a);const z=[o,s].map(R=>this.serializeTunnel(R));this.pushHistory({type:"extend-gap-fill",before:D,after:z,helperSleeve:E,metaBefore:S})}extendTunnelHalfGapPrecise(e,t,i,n,o){if(!e)return;const s=t.parameters||t,a=s.length||t.length||10,r=new u(0,0,1);r.clone().applyQuaternion(e.quaternion).normalize();const h=new V().setFromUnitVectors(r,n.clone());this.animateQuaternionSlerp(e,h,400);const l=o,d=a+l,c=i==="B"?1:-1,p=n.clone().multiplyScalar(c*l/2);if(s.length=d,typeof this.replaceTunnelGeometry=="function")this.replaceTunnelGeometry(e,s,{direction:n});else{e.geometry&&e.geometry.dispose();const m=(s.width||s.height||3)/2,y=new B(m,m,d,16,1,!1);y.rotateX(Math.PI/2),e.geometry=y}e.position.add(p),e.userData.parameters={...s},e.userData.objectData&&(e.userData.objectData.parameters={...s})}addConnectionMeta(e,t,i){var o;if(!((o=e==null?void 0:e.userData)!=null&&o.objectData))return;const n=e.userData.objectData;n.connectedTunnels||(n.connectedTunnels=[]),n.connectedTunnels.includes(i.id)||n.connectedTunnels.push(i.id)}createSegmentBlend(e,t,i,n){var O,A,q,R;const o=i.tunnel,s=n.tunnel;if(!o||!s)throw new Error("Missing tunnels");const a=e.position.clone(),r=t.position.clone(),h=r.clone().sub(a),l=h.length();if(l<.05)return;const d=h.clone().normalize(),c=a.clone().add(r).multiplyScalar(.5),p=i.meta.width||((O=i.meta.parameters)==null?void 0:O.width)||3,m=i.meta.height||((A=i.meta.parameters)==null?void 0:A.height)||p,y=n.data.width||((q=n.data.parameters)==null?void 0:q.width)||3,D=n.data.height||((R=n.data.parameters)==null?void 0:R.height)||y,S=Math.max(p,m)/2,w=Math.max(y,D)/2,g=6,b=new we;b.userData={selectable:!1,type:"blend-group",connects:[i.meta.id,n.data.id]};const x=new u(0,0,1),v=new V().setFromUnitVectors(x,d),E=l/2,z=g/2,C=(P,T,G,L)=>{const F=new B(L,G,T,20,1,!1);F.rotateX(Math.PI/2);const k=new X({color:4473924,shininess:30,specular:2236962}),$=new f(F,k);return $.castShadow=!0,$.receiveShadow=!0,$.setRotationFromQuaternion(v),$.position.copy(P.clone().add(d.clone().multiplyScalar(T/2))),$};for(let P=0;P<z;P++){const T=P/z,G=(P+1)/z,L=Q.lerp(S,(S+w)/2,T),F=Q.lerp(S,(S+w)/2,G),k=E/z,$=a.clone().add(d.clone().multiplyScalar(k*P));b.add(C($,k,L,F))}for(let P=0;P<z;P++){const T=P/z,G=(P+1)/z,L=Q.lerp((S+w)/2,w,T),F=Q.lerp((S+w)/2,w,G),k=E/z,$=c.clone().add(d.clone().multiplyScalar(k*P));b.add(C($,k,L,F))}this.scene.add(b),this.addConnectionMeta(o,i.meta,n.data),this.addConnectionMeta(s,n.data,i.meta),this.pushHistory({type:"segment-blend",groupRef:b,data:{posA:a,posB:r,rA:S,rB:w,segmentCount:g}})}animateQuaternionSlerp(e,t,i=400){const n=e.quaternion.clone(),o=performance.now(),s={object:e,startQuat:n,targetQuat:t.clone(),duration:i,start:o,done:!1},a=r=>{if(s.done)return;const h=Math.min(1,(r-o)/i);V.slerp(n,t,e.quaternion,h),h<1?requestAnimationFrame(a):s.done=!0};requestAnimationFrame(a)}async persistMergeRecord(e,t,i,n,o){if(this.enableMergePersistence)try{const s={strategy:e,mine_id:this.mineId,tunnels:[n.meta.id,o.data.id],endpoint_a:{x:t.position.x,y:t.position.y,z:t.position.z},endpoint_b:{x:i.position.x,y:i.position.y,z:i.position.z},timestamp:Date.now()},a=await fetch(this.mergePersistEndpoint,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify(s)});if(!a.ok)throw new Error("HTTP "+a.status);console.log("[MergePersist] Saved:",await a.json().catch(()=>"ok"))}catch(s){console.warn("[MergePersist] Failed:",s)}}ensureUndoRedoUI(){if(document.getElementById("undo-redo-panel"))return;const e=document.createElement("div");e.id="undo-redo-panel",e.style.cssText="position:absolute;top:10px;right:10px;z-index:9999;display:flex;gap:6px;font-family:Arial;";const t=(i,n,o)=>{const s=document.createElement("button");return s.id=i,s.textContent=n,s.style.cssText="padding:6px 10px;background:#222;color:#fff;border:1px solid #555;border-radius:4px;cursor:pointer;font-size:12px;",s.onclick=o,s};e.appendChild(t("btn-undo","Undo",()=>{this.undo()})),e.appendChild(t("btn-redo","Redo",()=>{this.redo()})),this.container.style.position=this.container.style.position||"relative",this.container.appendChild(e)}fuseTunnels(e,t,i,n){var G,L,F,k,$;if(!(i!=null&&i.tunnel)||!(n!=null&&n.tunnel))throw new Error("Missing tunnel references");const o=i.tunnel,s=n.tunnel,a=i.meta,r=n.data,h=[o,s].map(U=>this.serializeTunnel(U)),l=e.endpoint==="A"?"B":"A",d=t.endpoint==="A"?"B":"A",c=this.calculateTunnelEndpoint(o,l,a),p=this.calculateTunnelEndpoint(s,d,r),m=c.position.clone(),y=p.position.clone(),D=m.distanceTo(y);if(D<.05)throw new Error("Too short to fuse");const S=y.clone().sub(m).normalize(),w=a.width||((G=a.parameters)==null?void 0:G.width)||3,g=r.width||((L=r.parameters)==null?void 0:L.width)||3,b=a.height||((F=a.parameters)==null?void 0:F.height)||w,x=r.height||((k=r.parameters)==null?void 0:k.height)||g,v=Math.max(w,b)/2,E=Math.max(g,x)/2,z=new B(E,v,D,32,1,!1);z.rotateX(Math.PI/2);const C=z.attributes.position;for(let U=0;U<C.count;U++)C.getY(U);const O=new X({color:5592405,shininess:35,specular:3355443}),A=new f(z,O);A.castShadow=!0,A.receiveShadow=!0;const q=new u(0,0,1),R=new V().setFromUnitVectors(q,S);A.setRotationFromQuaternion(R),A.position.copy(m.clone().add(y).multiplyScalar(.5));const P=`fused_${a.id}_${r.id}`,T={length:D,width:Math.min(w,g),height:Math.min(b,x)};A.userData={selectable:!0,objectData:{id:P,type:"tunnel",parameters:T,width:T.width,height:T.height}},this.scene.add(A),($=this.objectSelector)!=null&&$.addSelectableObject&&this.objectSelector.addSelectableObject(A,A.userData.objectData),[o,s].forEach(U=>{U.visible=!1,U.userData.selectable=!1}),this.pushHistory({type:"merge-fuse",resultId:P,originals:h})}serializeTunnel(e){var n,o,s,a;const t=((n=e.userData)==null?void 0:n.objectData)||{},i=t.parameters||((o=e.userData)==null?void 0:o.parameters)||{};return{id:t.id,width:t.width||i.width,height:t.height||i.height,length:i.length,position:e.position.clone(),quaternion:e.quaternion.clone(),color:(a=(s=e.material)==null?void 0:s.color)!=null&&a.getHex?e.material.color.getHex():6710886}}recreateTunnel(e){var o;const t=Math.max(e.width||3,e.height||3)/2,i=new B(t,t,e.length,24,1,!1);i.rotateX(Math.PI/2);const n=new f(i,new X({color:e.color}));return n.position.copy(e.position),n.setRotationFromQuaternion(e.quaternion),n.castShadow=!0,n.receiveShadow=!0,n.userData={selectable:!0,objectData:{id:e.id,type:"tunnel",parameters:{length:e.length,width:e.width,height:e.height},width:e.width,height:e.height}},this.scene.add(n),(o=this.objectSelector)!=null&&o.addSelectableObject&&this.objectSelector.addSelectableObject(n,n.userData.objectData),n}pushHistory(e){this.actionHistory.undo.push(e),this.actionHistory.redo.length=0}undo(){var t,i,n;const e=this.actionHistory.undo.pop();if(e){if(e.type==="merge-fuse"){const o=this.findSelectableById(e.resultId);o&&(this.scene.remove(o),(t=o.geometry)==null||t.dispose()),e.originals.forEach(s=>this.recreateTunnel(s)),(i=this.updateAllTunnelEndpoints)==null||i.call(this)}else e.type==="extend-gap-fill"?(e.after.forEach(o=>{const s=this.findSelectableById(o.id);s&&this.scene.remove(s)}),e.before.forEach(o=>this.recreateTunnel(o)),e.helperSleeve&&(this.scene.remove(e.helperSleeve),e.helperSleeve.geometry.dispose()),(n=this.updateAllTunnelEndpoints)==null||n.call(this)):e.type==="segment-blend"&&e.groupRef&&e.groupRef.parent&&(e.groupRef.parent.remove(e.groupRef),e.groupRef.traverse(o=>{o.isMesh&&(o.geometry.dispose(),o.material.dispose())}));this.actionHistory.redo.push(e)}}redo(){var t,i,n;const e=this.actionHistory.redo.pop();if(e){if(e.type==="merge-fuse"){e.originals.forEach(a=>{const r=this.findSelectableById(a.id);r&&this.scene.remove(r)});const o=e.originals[0],s=e.originals[1];if(o&&s){const a=o.position.clone(),r=s.position.clone(),h=r.clone().sub(a).normalize(),l=a.distanceTo(r),d=new B(Math.max(s.width,s.height)/2,Math.max(o.width,o.height)/2,l,32,1,!1);d.rotateX(Math.PI/2);const c=new f(d,new X({color:5592405})),p=new u(0,0,1),m=new V().setFromUnitVectors(p,h);c.setRotationFromQuaternion(m),c.position.copy(a.clone().add(r).multiplyScalar(.5)),c.userData={selectable:!0,objectData:{id:e.resultId,type:"tunnel",parameters:{length:l,width:Math.min(o.width,s.width),height:Math.min(o.height,s.height)},width:Math.min(o.width,s.width),height:Math.min(o.height,s.height)}},this.scene.add(c),(t=this.objectSelector)!=null&&t.addSelectableObject&&this.objectSelector.addSelectableObject(c,c.userData.objectData)}(i=this.updateAllTunnelEndpoints)==null||i.call(this)}else if(e.type==="extend-gap-fill")e.before.forEach(o=>{const s=this.findSelectableById(o.id);s&&this.scene.remove(s)}),e.after.forEach(o=>this.recreateTunnel(o)),e.helperSleeve&&!e.helperSleeve.parent&&this.scene.add(e.helperSleeve),(n=this.updateAllTunnelEndpoints)==null||n.call(this);else if(e.type==="segment-blend"){const{posA:o,posB:s,rA:a,rB:r,segmentCount:h}=e.data,l=s.clone().sub(o),d=l.length(),c=l.clone().normalize(),p=o.clone().add(s).multiplyScalar(.5),m=new we,y=new u(0,0,1),D=new V().setFromUnitVectors(y,c),S=d/2,w=h/2,g=(b,x,v,E)=>{const z=new B(E,v,x,20,1,!1);z.rotateX(Math.PI/2);const C=new X({color:4473924}),O=new f(z,C);return O.setRotationFromQuaternion(D),O.position.copy(b.clone().add(c.clone().multiplyScalar(x/2))),O};for(let b=0;b<w;b++){const x=b/w,v=(b+1)/w,E=Q.lerp(a,(a+r)/2,x),z=Q.lerp(a,(a+r)/2,v),C=S/w,O=o.clone().add(c.clone().multiplyScalar(C*b));m.add(g(O,C,E,z))}for(let b=0;b<w;b++){const x=b/w,v=(b+1)/w,E=Q.lerp((a+r)/2,r,x),z=Q.lerp((a+r)/2,r,v),C=S/w,O=p.clone().add(c.clone().multiplyScalar(C*b));m.add(g(O,C,E,z))}this.scene.add(m),e.groupRef=m}this.actionHistory.undo.push(e)}}findSelectableById(e){let t=null;return this.scene.traverse(i=>{var n,o;!t&&((o=(n=i.userData)==null?void 0:n.objectData)==null?void 0:o.id)===e&&(t=i)}),t}createConnectionPath(e,t,i,n){var o,s,a,r,h;if(!this.pathDrawer){console.error("[TunnelConnection] PathDrawer not available");return}try{const l=e.map(v=>v&&v.isVector3?v:new u(v.x,v.y,v.z)),d=t.meta.width||((o=t.meta.parameters)==null?void 0:o.width)||3,c=i.data.width||((s=i.data.parameters)==null?void 0:s.width)||3,p=t.meta.height||((a=t.meta.parameters)==null?void 0:a.height)||3,m=i.data.height||((r=i.data.parameters)==null?void 0:r.height)||3,y=Math.min(d,c),D=Math.min(p,m),S=`${t.meta.id}-${i.data.id}-${n}`;let w=0;for(let v=0;v<S.length;v++)w=(w<<5)-w+S.charCodeAt(v),w|=0;const g=`merge_${Math.abs(w)}`;if(this.pathDrawer.paths.has(g))return console.warn("[TunnelConnection] Merge path already exists, skipping duplicate."),this.pathDrawer.paths.get(g);const b={id:g,points:l.map(v=>({x:v.x,y:v.y,z:v.z})),width:y,height:D,color:n==="curved"?"#00ff88":"#ffaa00",type:"tunnel",name:`Birleştirme Tüneli (${n})`,path_points:l.map(v=>({x:v.x,y:v.y,z:v.z}))},x=this.pathDrawer.createPath(b);if(console.log("[TunnelConnection] Created connection path:",x),this.objectSelector&&x){const v={id:g,type:"path",pathType:"tunnel",name:`Birleştirme Tüneli (${n})`,isConnection:!0,connectionType:n,connectedTunnels:[t.meta.id,i.data.id],width:y,height:D,points:l.map(E=>({x:E.x,y:E.y,z:E.z}))};this.objectSelector.addSelectableObject(x,v),setTimeout(()=>{this.createTunnelEndpoints(x,v)},50)}if(setTimeout(()=>{var v;(v=this.updateAllTunnelEndpoints)==null||v.call(this)},80),this.mineId&&((h=this.options)!=null&&h.enableMergePersistence)){const v={name:b.name,type:"tunnel",path_points:b.points,width:y,height:D,color:b.color,description:"Auto-created merge tunnel",material:"concrete"};fetch(`/api/mines/${this.mineId}/paths`,{method:"POST",headers:{"Content-Type":"application/json","X-Requested-With":"XMLHttpRequest"},body:JSON.stringify(v)}).then(E=>E.ok?E.json():Promise.reject(E)).then(E=>{var z;if((z=E==null?void 0:E.data)!=null&&z.id){const C=E.data.id;if(C!==g){if(this.pathDrawer.paths.has(g)){const O=this.pathDrawer.paths.get(g);this.pathDrawer.paths.delete(g),O.userData.id=C,this.pathDrawer.paths.set(C,O)}this.objectSelector&&this.objectSelector.selectableObjects&&this.objectSelector.selectableObjects.forEach(O=>{var A;((A=O==null?void 0:O.data)==null?void 0:A.id)===g&&(O.data.id=C)})}}}).catch(E=>console.warn("[TunnelConnection] Persist failed",E))}return x}catch(l){throw console.error("[TunnelConnection] Failed to create connection path:",l),l}}generateCurvedConnection(e,t){const i=e.position.clone(),n=t.position.clone();let o=e.direction?e.direction.clone():new u().subVectors(n,i).normalize(),s=t.direction?t.direction.clone().negate():new u().subVectors(i,n).normalize();const a=new u().subVectors(n,i).normalize();Math.abs(o.dot(a))<.3&&(o=a.clone()),Math.abs(s.clone().negate().dot(a))<.3&&(s=a.clone().negate());const r=i.distanceTo(n);new u().addVectors(i,n).multiplyScalar(.5);const h=Math.max(r*.3,5),l=i.clone().add(o.clone().multiplyScalar(h)),d=n.clone().add(s.clone().multiplyScalar(h)),c=[],p=Math.max(8,Math.floor(r/3));for(let m=0;m<=p;m++){const y=m/p,D=this.calculateBezierPoint(i,l,d,n,y);c.push(D)}return this.optimizeCurve(c)}calculateBezierPoint(e,t,i,n,o){const s=1-o,a=o*o,r=s*s,h=r*s,l=a*o,d=new u;return d.addScaledVector(e,h),d.addScaledVector(t,3*r*o),d.addScaledVector(i,3*s*a),d.addScaledVector(n,l),d}optimizeCurve(e,t=.5){if(e.length<=2)return e;const i=[e[0]];for(let n=1;n<e.length-1;n++){const o=i[i.length-1],s=e[n];o.distanceTo(s)>=t&&i.push(s)}return i.push(e[e.length-1]),i}animateEndpoints(){if(!this.mergeEndpoint1||!this.mergeEndpoint2)return;const e=Date.now(),t=2e3,i=()=>{const o=(Date.now()-e)%t/t,s=.8+.4*(Math.sin(o*Math.PI*2)*.5+.5);this.mergeEndpoint1&&this.mergeEndpoint1.scale.setScalar(s),this.mergeEndpoint2&&this.mergeEndpoint2.scale.setScalar(s),this.mergeEndpoint1&&this.mergeEndpoint2&&requestAnimationFrame(i)};i()}clearMergeVisualization(){this.mergeConnectionLine&&(this.scene.remove(this.mergeConnectionLine),this.mergeConnectionLine.geometry.dispose(),this.mergeConnectionLine.material.dispose(),this.mergeConnectionLine=null),this.mergeEndpoint1&&(this.scene.remove(this.mergeEndpoint1),this.mergeEndpoint1.geometry.dispose(),this.mergeEndpoint1.material.dispose(),this.mergeEndpoint1=null),this.mergeEndpoint2&&(this.scene.remove(this.mergeEndpoint2),this.mergeEndpoint2.geometry.dispose(),this.mergeEndpoint2.material.dispose(),this.mergeEndpoint2=null)}cancelTunnelMerge(){const e=document.getElementById("start-tunnel-merge"),t=document.getElementById("tunnel-merge-ui");e&&(e.style.display="block"),t&&(t.style.display="none"),this.clearMergeVisualization(),console.log("[TunnelMerge] Merge operation cancelled")}animateCameraTo(e,t,i=1500){if(!this.camera||!this.controls)return;const n=this.camera.position.clone(),o=this.controls.target.clone(),s=new u().copy(e),a=new u().copy(t);let r=null;const h=l=>{r||(r=l);const d=l-r,c=Math.min(d/i,1),p=c<.5?4*c*c*c:(c-1)*(2*c-2)*(2*c-2)+1;this.camera.position.lerpVectors(n,s,p),this.controls.target.lerpVectors(o,a,p),this.controls.update(),c<1&&requestAnimationFrame(h)};requestAnimationFrame(h)}showError(e){console.error("[TunnelMerge] Error:",e),window.toastr&&toastr.error(e)}showSuccess(e){console.log("[TunnelMerge] Success:",e),window.toastr&&toastr.success(e)}showInfo(e){console.info("[TunnelMerge] Info:",e),window.toastr&&toastr.info(e)}createTunnelEndpoints(e,t){if(!e||!t)return;const i=t.id;console.log("[EndpointSystem] Creating endpoints for tunnel:",i,t),this.endpointIndicators.has(i)&&this.removeTunnelEndpoints(i),e.geometry&&(e.geometry.computeBoundingBox(),e.updateMatrixWorld(!0));const n=this.calculateTunnelEndpoint(e,"A",t),o=this.calculateTunnelEndpoint(e,"B",t);if(console.log("[EndpointSystem] Calculated endpoints:",{endpointA:n,endpointB:o}),!n||!o){console.warn("[EndpointSystem] Could not calculate endpoints");return}const s=this.createEndpointMesh("A",16729156);s.position.copy(n.position),this.scene.add(s);const a=this.createEndpointMesh("B",4474111);a.position.copy(o.position),this.scene.add(a),this.endpointIndicators.set(i,{A:s,B:a,tunnel:e,metadata:t}),console.log(`[EndpointSystem] Created endpoints for tunnel ${i} at:`,{A:n.position.toArray(),B:o.position.toArray()})}createEndpointMesh(e,t){const i=new oe(1,32,32),n=new W({color:t,transparent:!0,opacity:.9}),o=new f(i,n),s=new oe(1.1,16,16),a=new W({color:16777215,wireframe:!0,transparent:!0,opacity:.8}),r=new f(s,a);o.add(r);const h=document.createElement("canvas"),l=h.getContext("2d");h.width=128,h.height=128,l.fillStyle=e==="A"?"#ff4444":"#4444ff",l.beginPath(),l.arc(64,64,60,0,2*Math.PI),l.fill(),l.strokeStyle="#ffffff",l.lineWidth=4,l.stroke(),l.fillStyle="#ffffff",l.font="bold 72px Arial",l.textAlign="center",l.textBaseline="middle",l.fillText(e,64,64);const d=new je(h),c=new Ae({map:d,transparent:!0,alphaTest:.1}),p=new Ge(c);return p.scale.set(3,3,1),p.position.set(0,2.5,0),o.add(p),o.userData={isEndpoint:!0,label:e,originalScale:o.scale.clone()},o}removeTunnelEndpoints(e){const t=this.endpointIndicators.get(e);t&&(t.A&&(this.scene.remove(t.A),t.A.geometry.dispose(),t.A.material.dispose()),t.B&&(this.scene.remove(t.B),t.B.geometry.dispose(),t.B.material.dispose()),this.endpointIndicators.delete(e))}updateAllTunnelEndpoints(){console.log("[EndpointSystem] Updating all tunnel endpoints...");for(const[t,i]of this.endpointIndicators)this.removeTunnelEndpoints(t);let e=0;if(this.scene.traverse(t=>{if(t.userData&&t.userData.selectable){const i=t.userData.objectData||t.userData;(i.type==="tunnel"||i.pathType==="tunnel")&&(console.log("[EndpointSystem] Found scene tunnel:",i),this.createTunnelEndpoints(t,i),e++)}}),this.pathDrawer&&this.pathDrawer.paths)for(const[t,i]of this.pathDrawer.paths){const n=i.userData.pathData;n&&n.type==="tunnel"&&(console.log("[EndpointSystem] Found path tunnel:",n),this.createTunnelEndpoints(i,n),e++)}console.log(`[EndpointSystem] Updated endpoints for ${e} tunnels`)}toggleEndpointVisibility(){this.showEndpoints=!this.showEndpoints;for(const[e,t]of this.endpointIndicators)t.A&&(t.A.visible=this.showEndpoints),t.B&&(t.B.visible=this.showEndpoints);console.log(`[EndpointSystem] Endpoints ${this.showEndpoints?"shown":"hidden"}`)}}window.SimpleMine3DViewer=kt;
